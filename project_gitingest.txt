================================================================
File: .gitignore
================================================================
# Python cache
__pycache__/
*.pyc

# Virtual environment folders
venv/
.env
env/

# Distribution / packaging
*.egg-info/

================================================================
File: benchmark.py
================================================================
import time
import os
import skimage.io
import neuron_tracker_core as ntc

def benchmark():
    # 1. Setup
    # Update this path to your real file
    path = "D:/SCN_GCaMP/Mus/120525-121025_Mus-Rhabdomys_series4.tif"
    
    print(f"Loading movie from {path}...")
    full_data = skimage.io.imread(path)
    
    # Slice first 200 frames for a quick test (remove slicing for full test)
    data = full_data[:200] 
    
    # Standard params
    params = {
        'sigma1': 3.0, 'sigma2': 20.0, 'blur_sigma': 2.0, 'max_features': 200
    }

    print(f"\n--- Benchmarking on {len(data)} frames ---")

    # 2. Serial Run (The "Old" Way)
    print("Running Serial Mode (n_processes=1)...")
    t0 = time.time()
    ntc.process_frames(data, n_processes=1, **params)
    t_serial = time.time() - t0
    print(f"Serial Time: {t_serial:.2f} seconds")

    # 3. Parallel Run (The "New" Way)
    print("Running Parallel Mode (n_processes=Default)...")
    t0 = time.time()
    # Default uses min(cpu_count, 8)
    ntc.process_frames(data, n_processes=None, **params)
    t_parallel = time.time() - t0
    print(f"Parallel Time: {t_parallel:.2f} seconds")

    # 4. Results
    speedup = t_serial / t_parallel
    print(f"\nSummary:")
    print(f"Speedup Factor: {speedup:.2f}x")
    if speedup > 1.5:
        print("SUCCESS: Significant performance gain detected.")
    else:
        print("WARNING: Speedup is negligible. Check CPU usage or shared memory overhead.")

if __name__ == "__main__":
    benchmark()

================================================================
File: benchmark_tuning.py
================================================================
# benchmark_tuning.py
import time
import os
import skimage.io
import neuron_tracker_core as ntc

def benchmark_tuning():
    # --- CONFIG ---
    # Update this path to your real file
    path = "D:/SCN_GCaMP/Mus/120525-121025_Mus-Rhabdomys_series4.tif"
    frames_to_test = 50  # 50 frames is enough to gauge speed
    
    # Params matching your typical workload
    params = {
        'sigma1': 3.0, 
        'sigma2': 20.0, 
        'blur_sigma': 2.0, 
        'max_features': 200
    }
    # --------------

    if not os.path.exists(path):
        print(f"Error: File not found at {path}")
        return

    print(f"Loading first {frames_to_test} frames from {os.path.basename(path)}...")
    full_data = skimage.io.imread(path)
    data = full_data[:frames_to_test]
    
    cpu_count = os.cpu_count() or 4
    # Test candidates: 1 (Serial), 4, 8, 12, 16, 24... up to actual CPU count
    candidates = [1, 4, 8, 12, 16, 24, 32]
    candidates = [n for n in candidates if n <= cpu_count]
    
    # Ensure at least one parallel run if possible
    if cpu_count > 1 and cpu_count not in candidates:
        candidates.append(cpu_count)
        candidates.sort()

    print(f"\n--- Tuning Benchmark (Frames: {frames_to_test}, Image Shape: {data.shape[1:]}) ---")
    print(f"{'Cores':<10} | {'Time (s)':<10} | {'Speedup':<10}")
    print("-" * 35)

    baseline_time = None
    
    for n in candidates:
        start_time = time.time()
        
        # Run detection
        ntc.process_frames(
            data, 
            n_processes=n, 
            progress_callback=None, # Silence output for clean benchmarking
            **params
        )
        
        elapsed = time.time() - start_time
        
        if n == 1:
            baseline_time = elapsed
            speedup = 1.0
        else:
            speedup = baseline_time / elapsed if baseline_time else 0.0
            
        print(f"{n:<10} | {elapsed:<10.2f} | {speedup:<10.2f}x")

    print("\nDone. Pick the N where speedup plateaus.")

if __name__ == "__main__":
    benchmark_tuning()

================================================================
File: cosinor.py
================================================================
# -*- coding: utf-8 -*-
"""
Cosinor Analysis Core Logic

Provides a function to perform single-component Cosinor analysis on time-series data.
"""
import numpy as np
from scipy import stats

def cosinor_analysis(data, time, period):
    """
    Performs a single-component Cosinor analysis on a time series.

    Args:
        data (np.ndarray): 1D array of the signal (e.g., intensity).
        time (np.ndarray): 1D array of time points corresponding to the data.
        period (float): The known period to fit the cosine function to.

    Returns:
        dict: A dictionary containing the results of the fit:
              'mesor', 'amplitude', 'acrophase', 'p_value', 'r_squared'.
              Returns a dict of NaNs if the fit fails.
    """
    # The model has 3 parameters (Mesor, Amp, Phase). 
    # If len(data) == 3, degrees of freedom (n - k) = 0, causing ZeroDivisionError later.
    if len(data) <= 3 or len(data) != len(time):
        return {
            'mesor': np.nan, 'amplitude': np.nan, 'acrophase': np.nan,
            'p_value': np.nan, 'r_squared': np.nan
        }

    # --- Setup the linear model: y = M + A*cos(2*pi*t/T) + B*sin(2*pi*t/T) ---
    w = 2 * np.pi / period
    X = np.array([
        np.ones_like(time),
        np.cos(w * time),
        np.sin(w * time)
    ]).T
    y = data

    # --- Perform Ordinary Least Squares (OLS) regression ---
    try:
        # (X'X)^-1 * X'y
        beta = np.linalg.inv(X.T @ X) @ X.T @ y
        M, A, B = beta[0], beta[1], beta[2]
    except np.linalg.LinAlgError:
        # Matrix is singular, fit cannot be performed
        return {
            'mesor': np.nan, 'amplitude': np.nan, 'acrophase': np.nan,
            'p_value': np.nan, 'r_squared': np.nan
        }

    # --- Calculate Cosinor parameters ---
    mesor = M
    amplitude = np.sqrt(A**2 + B**2)
    acrophase_rad = np.arctan2(B, A)
    acrophase = (acrophase_rad / w) % period

    # --- Calculate goodness-of-fit statistics (p-value and R^2) ---
    n = len(y)
    k = len(beta) # Number of parameters (3)
    
    y_fit = X @ beta
    residuals = y - y_fit
    
    sum_sq_total = np.sum((y - np.mean(y))**2)
    sum_sq_residuals = np.sum(residuals**2)
    
    if sum_sq_total == 0: # No variance in data
        return {
            'mesor': mesor, 'amplitude': amplitude, 'acrophase': acrophase,
            'p_value': np.nan, 'r_squared': 1.0
        }

    r_squared = 1 - (sum_sq_residuals / sum_sq_total)

    # F-statistic for zero-amplitude test
    sum_sq_model = sum_sq_total - sum_sq_residuals
    ms_model = sum_sq_model / (k - 1)
    ms_residuals = sum_sq_residuals / (n - k)

    if ms_residuals == 0: # Perfect fit
        p_value = 0.0
    else:
        f_statistic = ms_model / ms_residuals
        p_value = 1 - stats.f.cdf(f_statistic, k - 1, n - k)

    return {
        'mesor': mesor,
        'amplitude': amplitude,
        'acrophase': acrophase,
        'p_value': p_value,
        'r_squared': r_squared
    }

================================================================
File: neuron_analysis_app.py
================================================================
import sys
import os
from PyQt5 import QtWidgets, QtCore
from gui.main_window import MainWindow
from gui.theme import apply_theme, setup_matplotlib_theme

def main():
    # Enable High DPI display with PyQt5
    if hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'):
        QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)
    if hasattr(QtCore.Qt, 'AA_UseHighDpiPixmaps'):
        QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)

    app = QtWidgets.QApplication(sys.argv)
    
    # Set application details for QSettings
    QtCore.QCoreApplication.setOrganizationName("JonesLab")
    QtCore.QCoreApplication.setApplicationName("NeuronAnalysis")

    # Apply Theme
    apply_theme(app)
    setup_matplotlib_theme()

    win = MainWindow()
    win.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()


================================================================
File: neuron_tracker_core.py
================================================================
# -*- coding: utf-8 -*-
"""
Neuron Tracker Core Logic Library

This file contains all the core functions for the neuron tracking and data
extraction pipeline. It is designed to be a self-contained library.
"""

import os
import atexit
import numpy
import scipy.ndimage
import scipy.spatial
import networkx
from multiprocessing import Pool, shared_memory
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Optional, Union

# =============================================================================
# DATA STRUCTURES
# =============================================================================

@dataclass
class TrajectoryMetrics:
    """Quality metrics for a single trajectory candidate."""
    # Spatial Counts
    n_detected: int = 0
    
    # Coverage Metrics
    path_node_fraction: float = 0.0  # Legacy metric (len(path) / T)
    detected_fraction: float = 0.0   # Scientific metric (n_detected / T)
    
    # Spatial Quality
    max_gap: int = 0
    max_step: float = 0.0
    boundary_fail: bool = False
    
    # Jitter (Stability)
    spatial_jitter_raw: float = 0.0      
    spatial_jitter_detrended: float = 0.0 
    
    # Trace Metrics (Only computed if trace extracted)
    trace_snr_proxy: float = 0.0         # Median / MAD

@dataclass
class TrajectoryCandidate:
    """A single cell trajectory candidate with its metadata and data."""
    id: int
    pruned_path_nodes: list
    
    # Spatial Data
    positions: numpy.ndarray             # Shape (T, 2) [y, x]
    detected_mask: numpy.ndarray         # Shape (T,) boolean
    
    # Intensity Data (Optional, populated in Pass 2)
    trace: Optional[numpy.ndarray] = None # Shape (T,)
    
    # Metrics
    metrics: TrajectoryMetrics = field(default_factory=TrajectoryMetrics)
    
    # Pipeline State
    is_valid_spatial: bool = False  # Passed loose spatial gate?
    trace_extracted: bool = False   # Trace successfully sampled?
    accepted: bool = False          # Passed final policy?
    
    reject_reason: str = ""

# =============================================================================
# PARALLEL WORKER STATE & INIT
# =============================================================================

_shm_handle = None
_shm_arr = None

def _cleanup_worker():
    """Closes the shared memory handle on worker exit."""
    global _shm_handle
    if _shm_handle is not None:
        try:
            _shm_handle.close()
        except:
            pass
        _shm_handle = None

def _init_worker(shm_name, shape, dtype):
    """
    Initializes the worker process by attaching to the existing SharedMemory block.
    """
    global _shm_handle, _shm_arr
    try:
        _shm_handle = shared_memory.SharedMemory(name=shm_name)
        _shm_arr = numpy.ndarray(shape, dtype=dtype, buffer=_shm_handle.buf)
        atexit.register(_cleanup_worker)
    except Exception as e:
        print(f"Worker initialization failed: {e}")
        raise

# =============================================================================
# CORE DETECTION LOGIC
# =============================================================================

def _detect_features_in_image(im, sigma1, sigma2, blur_sigma, max_features):
    """Pure function to detect features in a single image array."""
    fltrd = (
        scipy.ndimage.gaussian_filter(-im, sigma1)
        - scipy.ndimage.gaussian_filter(-im, sigma2)
    )
    fltrd = rescale(fltrd, 0.0, 1.0)

    locations = list(zip(*detect_local_minima(fltrd)))

    if not locations:
        return []

    blurred_im = scipy.ndimage.gaussian_filter(im, blur_sigma)
    mags = [blurred_im[i, j] for i, j in locations]

    indices = numpy.argsort(mags)
    indices = indices[-max_features:]
    
    xys = [locations[i] for i in indices]
    return xys

def _process_frame_task_shared(t, sigma1, sigma2, blur_sigma, max_features):
    """Worker task: reads from shared memory, calculates features."""
    im = _shm_arr[t]
    xys = _detect_features_in_image(im, sigma1, sigma2, blur_sigma, max_features)
    return t, xys

def _process_frame_star(args):
    return _process_frame_task_shared(*args)


# =============================================================================
# PUBLIC API: HELPERS
# =============================================================================

def detect_local_minima(arr):
    """Takes a 2D array and detects local minima (troughs)."""
    neighborhood = scipy.ndimage.generate_binary_structure(len(arr.shape), 3)
    local_min = (scipy.ndimage.minimum_filter(arr, footprint=neighborhood) == arr)
    background = (arr == 0)
    eroded_background = scipy.ndimage.binary_erosion(
        background, structure=neighborhood, border_value=1
    )
    detected_minima = local_min ^ eroded_background
    return numpy.where(detected_minima)


def rescale(signal, minimum, maximum):
    """Rescales a numpy array to a new specified minimum and maximum range."""
    mins = numpy.min(signal)
    maxs = numpy.max(signal)
    if maxs == mins:
        return numpy.full(signal.shape, minimum)
    output = numpy.array(signal, dtype=float)
    output -= mins
    output *= (maximum - minimum) / (maxs - mins)
    output += minimum
    return output

# =============================================================================
# PUBLIC API: PIPELINE STEPS
# =============================================================================

def process_frames(data, sigma1, sigma2, blur_sigma, max_features, progress_callback=None, n_processes=None):
    """Step 1: Detect features in each frame."""
    if progress_callback is None:
        progress_callback = lambda msg: None

    T = data.shape[0]
    if n_processes is None:
        cpu = os.cpu_count() or 1
        n_processes = min(max(1, cpu - 2), 16)

    results = []
    step = max(1, T // 20)

    # --- SERIAL PATHWAY ---
    if n_processes < 2:
        progress_callback("Stage 1/4: Detecting features (Serial)...")
        for t in range(T):
            xys = _detect_features_in_image(data[t], sigma1, sigma2, blur_sigma, max_features)
            results.append((t, xys))
            if (t + 1) % step == 0 or t == T - 1:
                progress_callback(f"  Processed frame {t+1}/{T} ({100.0 * (t+1) / float(T):.1f}%)")

    # --- PARALLEL PATHWAY ---
    else:
        shm = shared_memory.SharedMemory(create=True, size=data.nbytes)
        try:
            shm_arr = numpy.ndarray(data.shape, dtype=data.dtype, buffer=shm.buf)
            shm_arr[:] = data[:] 
            
            progress_callback(f"Stage 1/4: Detecting features (Parallel on {n_processes} cores)...")
            
            tasks = ((t, sigma1, sigma2, blur_sigma, max_features) for t in range(T))
            init_args = (shm.name, data.shape, data.dtype)

            with Pool(processes=n_processes, initializer=_init_worker, initargs=init_args) as pool:
                for i, res in enumerate(pool.imap_unordered(_process_frame_star, tasks)):
                    results.append(res)
                    if (i + 1) % step == 0 or i == T - 1:
                        progress_callback(f"  Processed frame {i+1}/{T} ({100.0 * (i+1) / float(T):.1f}%)")
        finally:
            shm.close()
            shm.unlink()

    # Deterministic Assembly
    results.sort(key=lambda x: x[0])
    
    blob_lists, trees, ims, ids = [], [], [], {}
    
    for t, xys in results:
        ims.append(data[t]) 
        if not xys:
            blob_lists.append([])
            trees.append(None)
            continue
        for x, y in xys:
            ids[(t, (x, y))] = len(ids)
        trees.append(scipy.spatial.KDTree(xys))
        blob_lists.append(xys)

    return ims, ids, trees, blob_lists


def build_trajectories(
    blob_lists, trees, ids, search_range, cone_radius_base, cone_radius_multiplier, progress_callback=None,
):
    """Step 2: Connect features across frames."""
    if progress_callback is None:
        progress_callback = lambda msg: None

    T = len(blob_lists)
    graph = networkx.Graph()

    progress_callback("Stage 2/4: Building trajectories by connecting features...")
    step = max(1, T // 20) if T > 0 else 1

    for t in range(1, T):
        if (t + 1) % step == 0 or t == T - 1:
            progress_callback(f"  Connecting features up to frame {t+1}/{T} ({100.0 * (t+1) / float(T):.1f}%)")

        if not blob_lists[t]:
            continue

        for blob in blob_lists[t]:
            start = max(0, t - search_range)
            for bt in range(t - 1, start - 1, -1):
                if trees[bt] is None or not blob_lists[bt]:
                    continue
                distance, neighbor_idx = trees[bt].query(blob, 1)
                cone_radius = cone_radius_base + cone_radius_multiplier * (t - bt)
                if distance < cone_radius:
                    neighbor_coords = tuple(trees[bt].data[neighbor_idx])
                    graph.add_edge(ids[(bt, neighbor_coords)], ids[(t, blob)])
                    break

    subgraphs = list(networkx.connected_components(graph))
    return graph, subgraphs


def prune_trajectories(graph, subgraphs, ids, progress_callback=None):
    """Step 3: Prune branched trajectories."""
    if progress_callback is None:
        progress_callback = lambda msg: None

    progress_callback("Stage 3/4: Pruning branched trajectories...")

    reverse_ids = {v: k for k, v in ids.items()}
    pruned_subgraphs = []
    
    # Ensure deterministic processing order for subgraphs
    sorted_subgraphs = sorted(subgraphs, key=lambda nodes: min(nodes))

    for nodes in sorted_subgraphs:
        # Create a FRESH graph component and populate it in sorted order.
        # This guarantees that networkx's internal adjacency dicts have a fixed insertion order,
        # ensuring that BFS (shortest_path) tie-breaking is deterministic.
        sorted_nodes = sorted(list(nodes))
        subgraph_view = graph.subgraph(nodes)
        
        det_subgraph = networkx.Graph()
        det_subgraph.add_nodes_from(sorted_nodes)
        # Sort edges to ensure deterministic edge insertion order
        sorted_edges = sorted([tuple(sorted(e)) for e in subgraph_view.edges()])
        det_subgraph.add_edges_from(sorted_edges)

        nodes_by_time = {}
        for node in sorted_nodes:
            t, _ = reverse_ids[node]
            nodes_by_time.setdefault(t, []).append(node)

        times = sorted(nodes_by_time.keys())
        if len(times) < 2:
            continue

        # Deterministic start/end
        nodes_by_time[times[0]].sort()
        nodes_by_time[times[-1]].sort()
        
        start_node = nodes_by_time[times[0]][0]
        end_node = nodes_by_time[times[-1]][0]

        try:
            path = networkx.shortest_path(det_subgraph, start_node, end_node)
            if path:
                pruned_subgraphs.append(path)
        except networkx.NetworkXNoPath:
            continue

    progress_callback(f"  Found {len(pruned_subgraphs)} potential trajectories.")
    return pruned_subgraphs, reverse_ids


def extract_and_interpolate_data(
    ims, 
    pruned_subgraphs, 
    reverse_ids, 
    min_trajectory_length, 
    sampling_box_size, 
    sampling_sigma, 
    max_interpolation_distance, 
    progress_callback=None,
    mode='strict', # 'strict' or 'scored'
    return_candidates=False
):
    """Step 4: Two-Pass Pipeline (Spatial -> Trace)."""
    if progress_callback is None:
        progress_callback = lambda msg: None

    progress_callback("Stage 4/4: Filtering and sampling (Two-Pass Pipeline)...")

    T = len(ims)
    
    if sampling_box_size % 2 == 0:
        sampling_box_size += 1
    
    blur_kernel = numpy.zeros((sampling_box_size, sampling_box_size))
    center = sampling_box_size // 2
    blur_kernel[center, center] = 1.0
    blur_kernel = scipy.ndimage.gaussian_filter(blur_kernel, sampling_sigma)
    blur_kernel /= numpy.sum(blur_kernel)
    b_half = sampling_box_size // 2
    
    # Enforce shape invariant
    if T > 0:
        h0, w0 = ims[0].shape
        for t in range(1, T):
            if ims[t].shape != (h0, w0):
                raise ValueError(f"Frame dimensions mismatch at index {t}: expected {(h0, w0)}, got {ims[t].shape}")
        h, w = h0, w0
    else:
        h, w = 0, 0 # Fallback for empty (though T=0 is unlikely here)

    candidates: List[TrajectoryCandidate] = []

    # --- PASS 1: SPATIAL ANALYSIS & GATING ---
    for i, path in enumerate(pruned_subgraphs):
        if i > 0 and len(pruned_subgraphs) > 10 and i % (len(pruned_subgraphs) // 10) == 0:
            progress_callback(f"  Processing trajectory {i+1}/{len(pruned_subgraphs)}")

        # 1.1: Basic Interpolation
        known_pos = {}
        for node in path:
            t, c = reverse_ids[node]
            known_pos[t] = c
            
        detected_times = sorted(known_pos.keys())
        if not detected_times: continue
        
        # 1.2: Metrics Prep
        n_detected = len(detected_times)
        detected_mask = numpy.zeros(T, dtype=bool)
        detected_mask[detected_times] = True
        
        interpolated_pos = numpy.zeros((T, 2))
        for t in detected_times: interpolated_pos[t] = known_pos[t]
        interpolated_pos[:detected_times[0]] = known_pos[detected_times[0]]
        interpolated_pos[detected_times[-1] + 1:] = known_pos[detected_times[-1]]
        
        max_gap = 0
        for j in range(len(detected_times) - 1):
            t1, t2 = detected_times[j], detected_times[j+1]
            gap = t2 - t1 - 1
            if gap > max_gap: max_gap = gap
            if gap > 0:
                p1 = numpy.array(known_pos[t1])
                p2 = numpy.array(known_pos[t2])
                for t in range(t1 + 1, t2):
                    alpha = (t - t1) / (t2 - t1)
                    interpolated_pos[t] = p1 * (1.0 - alpha) + p2 * alpha

        # 1.3: Compute Spatial Metrics
        int_pos = numpy.round(interpolated_pos).astype(int)
        jumps = numpy.sqrt(numpy.sum(numpy.diff(int_pos, axis=0) ** 2, axis=1))
        max_step = numpy.max(jumps) if len(jumps) > 0 else 0.0

        y_coords = int_pos[:, 0]
        x_coords = int_pos[:, 1]
        in_bounds_y = (y_coords >= b_half) & (y_coords < h - b_half)
        in_bounds_x = (x_coords >= b_half) & (x_coords < w - b_half)
        boundary_fail = not numpy.all(in_bounds_y & in_bounds_x)

        if n_detected > 1:
            det_points = numpy.array([known_pos[t] for t in detected_times])
            std_devs = numpy.std(det_points, axis=0)
            spatial_jitter_raw = numpy.sqrt(numpy.sum(std_devs**2))
            
            smooth_path = scipy.ndimage.uniform_filter1d(det_points, size=5, axis=0, mode='nearest')
            residuals = det_points - smooth_path
            res_std = numpy.std(residuals, axis=0)
            spatial_jitter_detrended = numpy.sqrt(numpy.sum(res_std**2))
        else:
            spatial_jitter_raw = 0.0
            spatial_jitter_detrended = 0.0

        cand = TrajectoryCandidate(
            id=i,
            pruned_path_nodes=path,
            positions=int_pos,
            detected_mask=detected_mask,
        )
        cand.metrics.n_detected = n_detected
        cand.metrics.path_node_fraction = len(path) / T # Legacy metric
        cand.metrics.detected_fraction = n_detected / T # Scientific metric
        cand.metrics.max_gap = max_gap
        cand.metrics.max_step = max_step
        cand.metrics.boundary_fail = boundary_fail
        cand.metrics.spatial_jitter_raw = spatial_jitter_raw
        cand.metrics.spatial_jitter_detrended = spatial_jitter_detrended
        
        # 1.4: GATE LOGIC
        
        is_valid = False

        if mode == 'strict':
            # Strict Policy: Mimic legacy checks
            if cand.metrics.path_node_fraction < min_trajectory_length:
                cand.reject_reason = "min_length_strict"
                is_valid = False
            elif cand.metrics.boundary_fail:
                cand.reject_reason = "boundary_strict"
                is_valid = False
            elif cand.metrics.max_step > max_interpolation_distance:
                cand.reject_reason = "max_step_strict"
                is_valid = False
            else:
                is_valid = True
        else:
            # Scored Policy: Loose Gate
            if boundary_fail:
                cand.reject_reason = "boundary_physical"
                is_valid = False
            elif n_detected < 3:
                cand.reject_reason = "insufficient_points"
                is_valid = False
            elif cand.metrics.path_node_fraction < 0.01:
                 cand.reject_reason = "too_short_loose"
                 is_valid = False
            else:
                 is_valid = True

        cand.is_valid_spatial = is_valid
        candidates.append(cand)

    # --- PASS 2: TRACE EXTRACTION ---
    for cand in candidates:
        if not cand.is_valid_spatial:
            continue
            
        trace = numpy.zeros(T)
        for t in range(T):
            y, x = cand.positions[t]
            patch = ims[t][
                y - b_half : y + b_half + 1,
                x - b_half : x + b_half + 1,
            ]
            trace[t] = numpy.sum(patch * blur_kernel)
            
        cand.trace = trace
        cand.trace_extracted = True
        
        med = numpy.median(trace)
        mad = numpy.median(numpy.abs(trace - med))
        if mad > 0:
            cand.metrics.trace_snr_proxy = med / mad
        else:
            cand.metrics.trace_snr_proxy = 0.0

    # --- PASS 3: FINAL ACCEPTANCE ---
    for cand in candidates:
        # In strict mode, acceptance was already decided by the gate.
        # In scored mode, we accept everything that survived extraction (for now).
        if cand.trace_extracted:
            cand.accepted = True
        else:
            cand.accepted = False
            
    # --- OUTPUT GENERATION ---
    if return_candidates:
        return candidates

    final_coms = []
    final_trajectories = []
    final_lines = []
    
    for cand in candidates:
        # Safety: trace must be present to write output
        if cand.accepted and cand.trace is not None:
            line_data = numpy.column_stack((numpy.arange(T), cand.trace))
            final_coms.append(numpy.mean(cand.positions, axis=0))
            final_trajectories.append(cand.positions)
            final_lines.append(line_data)
            
    return (
        numpy.array(final_coms),
        numpy.array(final_trajectories),
        numpy.array(final_lines),
    )

================================================================
File: README.md
================================================================
# Neuron Tracker and Analysis Suite

## Project Overview

This suite of tools provides a complete, end-to-end pipeline for the analysis of cellular bioluminescence or fluorescence imaging data, specifically tailored for studying circadian rhythms in neuronal ensembles like the Suprachiasmatic Nucleus (SCN).

The application supports a comprehensive workflow within a single, user-friendly graphical interface:
1.  **Single Animal Analysis:** Process a raw movie (`.tif`) to detect and track individual cells, extract their intensity traces, and generate interactive visualizations (heatmaps, phase maps, etc.).
2.  **Atlas Registration:** A landmark-based warping tool to register multiple individual animal datasets into a common, standardized atlas space.
3.  **Apply Warp:** Transform ROI coordinates from individual datasets into common atlas space using calculated warp parameters.
4.  **Group Analysis:** Pool data from multiple warped datasets to generate group-level visualizations, such as a group phase distribution scatter plot and a group average phase map.

The application features a powerful, interactive visualization environment, allowing users to click on any cell in a spatial plot to instantly view its detailed trajectory and intensity trace over time.

---

## Installation

This project requires Python 3. The necessary external libraries can be installed in a single step using the provided `requirements.txt` file.

1.  Open a terminal or command prompt.
2.  Navigate to the directory containing the project files.
3.  Run the following command:
    ```    
	pip install -r requirements.txt
    ```
---

## Core Workflows

The application is organized around four primary scientific workflows, accessible via the numbered navigation list on the left side of the main window.

### Workflow 1: Single Animal Analysis

This is the foundational workflow for processing a single movie and exploring its results.

1.  **Launch the Application:**
    ```
    python neuron_analysis_app.py
    ```
2.  **Load a Movie:** In the "1. Single Animal Analysis" panel, click **"Load Movie..."** and select your raw `.tif` file.
3.  **Run Analysis:** Click **"Run Analysis"** in the Global Actions section. This will detect, track, and extract data for all cells, which may take several minutes.
4.  **Load Results:** Once the analysis is complete, click **"Load Results"** in the Global Actions section. This will populate all the interactive visualization tabs on the right.

### Workflow 2: Atlas Registration

This workflow is for aligning multiple datasets to a common atlas. This requires that you have already run the single-animal analysis on each animal and used the **"Define Anatomical ROI..."** tool to create an `_anatomical_roi.json` file for each.

1.  Select **"2. Atlas Registration"** from the navigation list.
2.  Select your master atlas file (which is itself an `_anatomical_roi.json` file).
3.  Add one or more target `_anatomical_roi.json` files from your individual animals.
4.  Click **"Begin Registration..."** to launch the landmark-placement tool. For each target, place 3+ corresponding landmarks on the atlas and the target to calculate the warp.

### Workflow 3: Apply Warp

After registering datasets to an atlas, use this workflow to apply the calculated warps to your analysis results.

1.  Select **"3. Apply Warp"** from the navigation list.
2.  Load the warp parameter files (`.json`) generated during registration.
3.  Click **"Apply Warp to ROI Data"** to transform your ROI coordinates into atlas space.

### Workflow 4: Group Analysis

This workflow is for visualizing data from multiple animals that have already been warped to the atlas space.

1.  Select **"4. Group Analysis"** from the navigation list.
2.  Click **"Add Warped ROI File(s)..."** and select all the `_roi_warped.csv` files you want to include in the group.
3.  Click **"Generate Group Visualizations"**. This will populate the "Grp Scatter" and "Grp Avg Map" tabs.

---

## Guide to Interactive Visualizations

The power of this tool lies in its interconnected visualization tabs.

### Visualization Tabs

The application includes seven visualization tabs on the right side:
- **Heatmap:** Displays all cell intensity traces as rows, with sortable ordering
- **CoM (Center of Mass):** Spatial plot of all detected cells with adjustable contrast
- **Trajectories:** Frame-by-frame visualization of individual cell trajectories
- **Phase Map:** Spatial visualization of rhythmic cells colored by their peak timing
- **Interp Map:** Interpolated spatial representation of phase patterns
- **Grp Scatter:** Combined scatter plot from multiple warped datasets (group analysis)
- **Grp Avg Map:** Averaged phase map across multiple animals (group analysis)

### Interactive Selection

*   **Click-to-Select:** In the **"CoM"** or **"Phase Map"** tabs, you can click directly on any cell's dot.
*   **View Trajectory:** The application will automatically switch to the **"Trajectories"** tab and display the full trajectory of the selected cell.
*   **View Intensity Trace:** The application will also update the line plot at the bottom of the **"Heatmap"** tab to show the raw intensity trace for the selected cell.
*   **Cross-Plot Highlighting:** The selected cell will be highlighted with a circle on all relevant plots so you never lose context.

### Trajectory Inspector with Frame Scrubbing

The **"Trajectories"** tab is a powerful validation tool.
*   Use the **"Previous" / "Next"** buttons to step through different cells.
*   Use the **"Frame"** slider at the bottom to scrub through the movie frame by frame. The background image will update, and a prominent marker will show the cell's exact position at that moment in time, allowing you to visually confirm the tracking accuracy.

### Advanced Heatmap Features

The **"Heatmap"** tab is a central analysis tool.
*   **Sorting:** The radio buttons allow you to sort the heatmap by scientifically relevant criteria:
    *   **Y-coordinate:** Sorts cells spatially from top to bottom.
    *   **Phase:** Sorts cells by their calculated peak time, making temporal patterns (like waves) easy to see.
    *   **Rhythmicity:** Sorts cells by the quality of their rhythm (either SNR or R-squared). This brings the "best" cells to the top.
*   **Rhythm Emphasis:** In the "Phase Map Parameters" panel, check **"Emphasize rhythmic cells"**. This will visually de-emphasize non-rhythmic cells in both the "CoM" plot (making them gray) and the "Heatmap" (covering them with a semi-transparent gray mask), allowing you to focus on the data of interest without losing context.

### Choice of Analysis Method

In the "Phase Map Parameters" panel, you can choose your rhythm analysis engine from the **"Analysis Method"** dropdown.

*   **FFT (SNR):** This model-free method is excellent for discovering rhythms and analyzing non-sinusoidal data. The "rhythmicity score" is a signal-to-noise ratio, where a value > 2.0 is a good starting point for a confident rhythm.
*   **Cosinor (p-value):** This model-based method is statistically rigorous and provides standard circadian parameters. It uses a two-factor threshold:
    *   **p-value:** The statistical significance of the rhythm's existence (e.g., `<= 0.05`).
    *   **R-squared:** The "goodness of fit," or how much of the data's variance is explained by the cosine model (e.g., `>= 0.3`).

---

## Acknowledgements

This project is a significant refactoring, modernization, and extension of an original analysis workflow developed in the Herzog Lab. The core scientific algorithms are based on the excellent foundational work of others, and we gratefully acknowledge their contributions:

*   **Ben Bales (Petzold Lab, UCSB):** For writing the original `extract_data.py` Python script, which forms the core of the neuron tracking algorithm.
*   **Matt Tso (Herzog Lab, WashU):** For developing the initial workflow, creating the supplementary analysis scripts, and for the presentation that inspired this project.

================================================================
File: requirements.txt
================================================================
numpy==1.26.4
scipy==1.13.1
scikit-image>=0.24.0,<0.26
scikit-learn==1.5.0
matplotlib==3.9.0
networkx==3.3
PyQt5==5.15.10
colorcet==3.1.0
pandas==2.2.2

================================================================
File: run_tracker_cli.py
================================================================
"""
Neuron Tracker - Command-Line Interface (CLI)

This script provides a command-line interface to the neuron tracking tool.
It is designed for users who want to automate the analysis or run it in a
scripting environment.

It imports its core logic from 'neuron_tracker_core.py'.
"""

import os
import sys
import argparse
import skimage.io
import numpy
import matplotlib.pyplot as plt

# Import the core processing functions from the separate library file.
import neuron_tracker_core as ntc

def main():
    """
    Main function to parse command-line arguments and run the full pipeline.
    """
    # --- Argument Parsing ---
    parser = argparse.ArgumentParser(
        description="Neuron Tracking and Data Extraction Tool (CLI).",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("input_file", help="Path to the input image file (e.g., a multi-frame TIFF).")
    parser.add_argument("--output_basename", help="Basename for the output CSV files. If not provided, it is derived from the input file name.")
    parser.add_argument("--visualize", action="store_true", help="If set, display summary plots after processing.")
    
    g1 = parser.add_argument_group('Feature Detection Parameters')
    g1.add_argument('--sigma1', type=float, default=3.0, help="Sigma for the smaller Gaussian in DoG filter.")
    g1.add_argument('--sigma2', type=float, default=20.0, help="Sigma for the larger Gaussian in DoG filter.")
    g1.add_argument('--blur_sigma', type=float, default=2.0, help="Sigma for blurring before measuring feature magnitude.")
    g1.add_argument('--max_features', type=int, default=200, help="Max number of features to detect per frame.")

    g2 = parser.add_argument_group('Trajectory Building Parameters')
    g2.add_argument('--search_range', type=int, default=50, help="Number of previous frames to search for a connection.")
    g2.add_argument('--cone_radius_base', type=float, default=1.5, help="Base radius for the backward search cone.")
    g2.add_argument('--cone_radius_multiplier', type=float, default=0.125, help="Growth factor for the search cone radius per frame.")

    g3 = parser.add_argument_group('Filtering and Sampling Parameters')
    g3.add_argument('--min_trajectory_length', type=float, default=0.08, help="Minimum trajectory length as a fraction of total frames.")
    g3.add_argument('--sampling_box_size', type=int, default=15, help="Side length of the intensity sampling box (must be odd).")
    g3.add_argument('--sampling_sigma', type=float, default=2.0, help="Sigma of the Gaussian for weighted intensity sampling.")
    g3.add_argument('--max_interpolation_distance', type=float, default=5.0, help="Safety check: max allowed pixel distance between frames in a final trajectory.")

    args = parser.parse_args()

    # --- 1. Load and Prepare Data ---
    print(f"Loading data from {args.input_file}...")
    try:
        data = skimage.io.imread(args.input_file)
    except FileNotFoundError:
        print(f"Error: Input file not found at '{args.input_file}'", file=sys.stderr)
        sys.exit(1)
        
    data = ntc.rescale(data, 0.0, 1.0)

    # --- 2. Run Core Processing Pipeline ---
    progress_callback = lambda msg: print(msg)
    ims, ids, trees, blob_lists = ntc.process_frames(data, args.sigma1, args.sigma2, args.blur_sigma, args.max_features, progress_callback)
    graph, subgraphs = ntc.build_trajectories(blob_lists, trees, ids, args.search_range, args.cone_radius_base, args.cone_radius_multiplier, progress_callback)
    pruned_subgraphs, reverse_ids = ntc.prune_trajectories(graph, subgraphs, ids, progress_callback)
    com, traj, lines = ntc.extract_and_interpolate_data(ims, pruned_subgraphs, reverse_ids, args.min_trajectory_length, args.sampling_box_size, args.sampling_sigma, args.max_interpolation_distance, progress_callback)

    # --- 3. Handle Results and Save Files ---
    if len(lines) == 0:
        print("\nProcessing complete, but no valid trajectories were found.", file=sys.stderr)
        print("Consider adjusting the parameters.", file=sys.stderr)
        sys.exit(0)

    print(f"\nProcessing complete. Found {len(lines)} valid trajectories.")
    basename = args.output_basename if args.output_basename else os.path.splitext(os.path.basename(args.input_file))[0]
    
    roi_filename = f"{basename}_roi.csv"
    roi_data = numpy.column_stack((com[:, 1], com[:, 0]))
    numpy.savetxt(roi_filename, roi_data, delimiter=',')
    print(f"Saved center-of-mass data to {roi_filename}")

    traces_filename = f"{basename}_traces.csv"
    time_column = lines[0, :, 0]
    intensity_data = lines[:, :, 1].T
    traces_data = numpy.column_stack((time_column, intensity_data))
    numpy.savetxt(traces_filename, traces_data, delimiter=",")
    print(f"Saved intensity traces to {traces_filename}")

    # --- 4. Save the full trajectory data ---
    traj_filename = f"{basename}_trajectories.npy"
    numpy.save(traj_filename, traj)
    print(f"Saved full trajectory data to {traj_filename}")


    # --- 5. Optional Visualization ---
    if args.visualize:
        print("Generating visualizations...")
        plt.figure(figsize=(12, 8))
        for line in lines: plt.plot(line[:, 0], line[:, 1])
        plt.title(f"All {len(lines)} Intensity Traces"); plt.xlabel("Time (frames)"); plt.ylabel("Normalized Intensity")
        plt.show()

        plt.figure(figsize=(10, 10))
        plt.imshow(ims[len(ims) // 2], cmap='gray')
        plt.plot(com[:, 1], com[:, 0], '.', color='red', markersize=5, alpha=0.7)
        plt.title("Center of Mass of All Trajectories")
        plt.show()

        if len(traj) > 0:
            plt.figure(figsize=(10, 10))
            single_traj = traj[0, :, :]
            time_colors = numpy.arange(single_traj.shape[0])
            plt.scatter(single_traj[:, 1], single_traj[:, 0], c=time_colors, cmap='viridis', s=10)
            cbar = plt.colorbar(); cbar.set_label('Time (frames)', rotation=270, labelpad=15)
            plt.title("Movement of a Single Trajectory (Trajectory 0)")
            plt.xlim(0, ims[0].shape[1]); plt.ylim(ims[0].shape[0], 0)
            plt.show()

if __name__ == "__main__":
    main()

================================================================
File: test_equivalence.py
================================================================
import unittest
import numpy as np
import scipy.ndimage
import scipy.spatial
import networkx
import random
import neuron_tracker_core as ntc

# =============================================================================
# LEGACY BASELINE IMPLEMENTATION (FROZEN)
# =============================================================================

def _legacy_detect_local_minima(arr):
    neighborhood = scipy.ndimage.generate_binary_structure(len(arr.shape), 3)
    local_min = (scipy.ndimage.minimum_filter(arr, footprint=neighborhood) == arr)
    background = (arr == 0)
    eroded_background = scipy.ndimage.binary_erosion(
        background, structure=neighborhood, border_value=1
    )
    detected_minima = local_min ^ eroded_background
    return np.where(detected_minima)

def _legacy_rescale(signal, minimum, maximum):
    mins = np.min(signal)
    maxs = np.max(signal)
    if maxs == mins:
        return np.full(signal.shape, minimum)
    output = np.array(signal, dtype=float)
    output -= mins
    output *= (maximum - minimum) / (maxs - mins)
    output += minimum
    return output

def legacy_extract_and_interpolate_data(
    ims, pruned_subgraphs, reverse_ids, min_trajectory_length, sampling_box_size, sampling_sigma, max_interpolation_distance
):
    """
    Original extraction logic, preserved for regression testing.
    """
    T = len(ims)
    lines, coms, trajectories = [], [], []

    if sampling_box_size % 2 == 0:
        sampling_box_size += 1

    blur = np.zeros((sampling_box_size, sampling_box_size))
    center = sampling_box_size // 2
    blur[center, center] = 1.0
    blur = scipy.ndimage.gaussian_filter(blur, sampling_sigma)
    blur /= np.sum(blur)

    for i, path in enumerate(pruned_subgraphs):
        if len(path) < min_trajectory_length * T:
            continue

        interpolated_pos = {}
        interpolated_val = {}

        for node in path:
            t, c = reverse_ids[node]
            interpolated_pos[t] = c

        detected_times = sorted(interpolated_pos.keys())
        if not detected_times:
            continue

        start_pos = interpolated_pos[detected_times[0]]
        for t in range(0, detected_times[0]):
            interpolated_pos[t] = start_pos

        end_pos = interpolated_pos[detected_times[-1]]
        for t in range(detected_times[-1] + 1, T):
            interpolated_pos[t] = end_pos

        for j in range(len(detected_times) - 1):
            lt, rt = detected_times[j], detected_times[j + 1]
            if rt == lt + 1:
                continue
            lc = np.array(interpolated_pos[lt])
            rc = np.array(interpolated_pos[rt])
            for t in range(lt + 1, rt):
                alpha = float(t - lt) / (rt - lt)
                interpolated_pos[t] = tuple(lc * (1.0 - alpha) + rc * alpha)

        full_trajectory = []
        cancel = False
        b_half = sampling_box_size // 2

        for t in range(T):
            c = np.round(np.array(interpolated_pos[t])).astype(int)
            full_trajectory.append(c)

            h, w = ims[t].shape
            y, x = c

            if not (b_half <= y < h - b_half and b_half <= x < w - b_half):
                cancel = True
                break

            patch = ims[t][
                y - b_half : y + b_half + 1,
                x - b_half : x + b_half + 1,
            ]
            interpolated_val[t] = np.sum(patch * blur)

        if cancel:
            continue

        full_trajectory = np.array(full_trajectory)

        distances = np.sqrt(np.sum(np.diff(full_trajectory, axis=0) ** 2, axis=1))
        if np.any(distances > max_interpolation_distance):
            continue

        coms.append(np.mean(full_trajectory, axis=0))
        trajectories.append(full_trajectory)
        lines.append(np.array(sorted(interpolated_val.items())))

    return (
        np.array(coms),
        np.array(trajectories),
        np.array(lines),
    )

def legacy_reference_process_frames(data, sigma1, sigma2, blur_sigma, max_features):
    blob_lists, trees, ims, ids = [], [], [], {}
    T = data.shape[0]

    for t in range(T):
        im = data[t]
        ims.append(im)
        fltrd = (
            scipy.ndimage.gaussian_filter(-im, sigma1)
            - scipy.ndimage.gaussian_filter(-im, sigma2)
        )
        fltrd = _legacy_rescale(fltrd, 0.0, 1.0)
        locations = list(zip(*_legacy_detect_local_minima(fltrd)))

        if not locations:
            blob_lists.append([])
            trees.append(None)
            continue

        blurred_im = scipy.ndimage.gaussian_filter(im, blur_sigma)
        mags = [blurred_im[i, j] for i, j in locations]

        indices = np.argsort(mags)
        indices = indices[-max_features:]
        xys = [locations[i] for i in indices]

        for x, y in xys:
            ids[(t, (x, y))] = len(ids)

        trees.append(scipy.spatial.KDTree(xys))
        blob_lists.append(xys)

    return ims, ids, trees, blob_lists


# =============================================================================
# EQUIVALENCE TEST SUITE
# =============================================================================

class TestNeuronTrackerEquivalence(unittest.TestCase):
    def setUp(self):
        # Synthetic Movie
        np.random.seed(12345) 
        self.frames = np.random.rand(10, 64, 64).astype(np.float32)
        for t in range(10):
            y, x = 20 + t, 20 + t
            self.frames[t, y-2:y+3, x-2:x+3] += 5.0 
        for t in range(10):
            self.frames[t, 40:45, 40:45] += 5.0

        self.params = {
            'sigma1': 1.0, 'sigma2': 5.0, 'blur_sigma': 1.0, 'max_features': 10
        }
        self.extract_params = {
            'min_trajectory_length': 0.1, # 1 frame out of 10
            'sampling_box_size': 5,
            'sampling_sigma': 1.0,
            'max_interpolation_distance': 10.0
        }

    def canonicalize_edges(self, graph):
        return sorted([tuple(sorted(e)) for e in graph.edges()])

    def test_tiebreaker_determinism(self):
        """
        Verify that prune_trajectories breaks ties deterministically even if
        graph construction order is randomized.
        """
        print("\nRunning Randomized Tie-Breaker Stress Test (100 iterations)...")
        nodes = [0, 1, 2, 3]
        base_edges = [(0,1), (0,2), (1,3), (2,3)] # Two equal paths: 0-1-3 and 0-2-3
        
        ids = {
            (0, (0,0)): 0, 
            (1, (10,10)): 1, 
            (1, (20,20)): 2, 
            (2, (30,30)): 3
        }
        subgraphs = [{0, 1, 2, 3}]
        
        reference_path = None
        
        for i in range(100):
            # Adversarial randomization: Shuffle edge insertion order
            edges = list(base_edges)
            random.shuffle(edges)
            
            G = networkx.Graph()
            G.add_nodes_from(nodes)
            G.add_edges_from(edges)

            pruned, _ = ntc.prune_trajectories(G, subgraphs, ids, progress_callback=lambda m:None)
            
            self.assertEqual(len(pruned), 1, "Should pick exactly one path")
            path = pruned[0]
            
            if reference_path is None:
                reference_path = path
            else:
                self.assertEqual(path, reference_path, f"Tie-break failed at iter {i}: {path} vs {reference_path}")
                
        print(f"  [OK] Tie-breaking is deterministic (Path: {reference_path}).")

    def test_full_pipeline_equivalence_loop(self):
        print("\nRunning Full Pipeline Loop (50 iterations)...")
        
        # 1. Legacy Baseline (Computed Once)
        ims_L, ids_L, trees_L, blobs_L = legacy_reference_process_frames(self.frames, **self.params)
        
        # Note: We must use ntc.build_trajectories because we didn't freeze that one.
        # This is safe because build_trajectories logic wasn't refactored significantly.
        graph_L, subs_L = ntc.build_trajectories(blobs_L, trees_L, ids_L, 5, 5.0, 0.1)
        
        # We must use ntc.prune_trajectories, which NOW HAS SORTING.
        # This guarantees that the legacy run output is also deterministic.
        pruned_L, rev_ids_L = ntc.prune_trajectories(graph_L, subs_L, ids_L)
        
        com_L, traj_L, lines_L = legacy_extract_and_interpolate_data(
            ims_L, pruned_L, rev_ids_L, **self.extract_params
        )
        
        for i in range(50):
            # 2. New Core (Parallel)
            ims_N, ids_N, trees_N, blobs_N = ntc.process_frames(self.frames, n_processes=2, progress_callback=None, **self.params)
            graph_N, subs_N = ntc.build_trajectories(blobs_N, trees_N, ids_N, 5, 5.0, 0.1)
            pruned_N, rev_ids_N = ntc.prune_trajectories(graph_N, subs_N, ids_N, progress_callback=None)
            com_N, traj_N, lines_N = ntc.extract_and_interpolate_data(
                ims_N, pruned_N, rev_ids_N, **self.extract_params, mode='strict', progress_callback=None
            )

            # 3. Assertions
            self.assertEqual(len(blobs_L), len(blobs_N))
            np.testing.assert_array_equal(com_L, com_N)
            
            # Trajectories (list of arrays)
            for tl, tn in zip(traj_L, traj_N):
                np.testing.assert_array_equal(tl, tn)
                
            # Lines
            for ll, ln in zip(lines_L, lines_N):
                np.testing.assert_array_equal(ll, ln)
                
        print("  [OK] 50/50 runs matched legacy bit-exact.")
        print("SUCCESS.")

if __name__ == '__main__':
    unittest.main()

================================================================
File: gui\analysis.py
================================================================
import numpy as np
from scipy.signal import medfilt, find_peaks

# ------------------------------------------------------------
# Phase calculation
# ------------------------------------------------------------

RHYTHM_TREND_WINDOW_HOURS = 36.0  # default detrend timescale for circadian work

def compute_median_window_frames(minutes_per_frame, trend_window_hours, T=None):
    """
    Compute an odd-length median filter window in frames for a given trend window in hours.

    Parameters:
        minutes_per_frame : float
            Sampling interval in minutes.
        trend_window_hours : float
            Desired width of the detrending window in hours.
        T : int or None
            Optional number of frames in the trace, used to cap the window.

    Returns:
        median_window_frames : int (odd, >= 3)
    """
    if minutes_per_frame <= 0:
        # Fallback: use a small default window in frames if sampling is invalid
        frames = 3
    else:
        hours_per_frame = minutes_per_frame / 60.0
        if hours_per_frame <= 0:
            frames = 3
        else:
            frames = int(round(trend_window_hours / hours_per_frame))
            if frames < 3:
                frames = 3

    # Enforce odd window size
    if frames % 2 == 0:
        frames += 1

    # Cap by T if provided and meaningful
    if T is not None and T > 0:
        if frames > T:
            frames = T if (T % 2 == 1) else (T - 1)
            if frames < 3:
                frames = 3

    return frames

def preprocess_for_rhythmicity(trace, method="running_median",
                               median_window_frames=None,
                               poly_order=2):
    """
    Preprocess a raw fluorescence trace before rhythmicity analysis.
    Returns a detrended trace suitable for FFT or cosinor.

    Parameters:
        trace: 1D numpy array
        method: "running_median", "polynomial", or "none"
        median_window_frames: int or None
            If None and method == "running_median", caller must have computed a
            suitable window; this function will fall back to a small default.
        poly_order: polynomial order for polynomial detrending

    Returns:
        detrended_trace: 1D numpy array
    """
    trace = np.asarray(trace, dtype=float)

    if method == "none":
        return trace.copy()

    x = np.arange(len(trace))

    if method == "running_median":
        # If the caller did not provide a window, fall back to a minimal safe default.
        if median_window_frames is None:
            median_window_frames = 3
        if median_window_frames % 2 == 0:
            median_window_frames += 1
        baseline = medfilt(trace, kernel_size=median_window_frames)
        detrended = trace - baseline
        return detrended

    if method == "polynomial":
        # Global polynomial baseline
        if trace.size < (poly_order + 1):
            return trace.copy()
        coeffs = np.polyfit(x, trace, poly_order)
        baseline = np.polyval(coeffs, x)
        detrended = trace - baseline
        return detrended

    # Fallback
    return trace.copy()

def estimate_cycle_count_from_trace(
    trace,
    minutes_per_frame,
    period_hours,
    detrend_method="running_median",
    median_window_frames=None,
    trend_window_hours=RHYTHM_TREND_WINDOW_HOURS,
    smoothing_window_hours=2.0,
    min_prominence_fraction=0.2,
):
    """
    Estimate how many cycles a single trace contains around a target period.

    Parameters:
        trace : 1D array-like
            Raw fluorescence trace for one cell.
        minutes_per_frame : float
            Sampling interval in minutes.
        period_hours : float
            Target period (e.g., 24.0 for circadian).
        detrend_method : str
            Method passed to preprocess_for_rhythmicity ("running_median", "polynomial", or "none").
        median_window_frames : int or None
            If None and detrend_method == "running_median", window is derived from
            minutes_per_frame and trend_window_hours.
        trend_window_hours : float
            Trend window in hours for dynamic median-window computation.
        smoothing_window_hours : float
            Width of the smoothing window (in hours) for peak detection.
        min_prominence_fraction : float
            Minimum peak prominence as a fraction of the smoothed trace amplitude range.

    Returns:
        n_cycles : int
            Estimated number of cycles (roughly number of usable peaks minus 1).
        peak_indices : 1D np.ndarray of ints
            Indices of peaks used for counting.
    """
    trace = np.asarray(trace, dtype=float)
    T = trace.shape[0]
    if T < 3:
        return 0, np.array([], dtype=int)

    # Choose median window in frames if needed
    if detrend_method == "running_median" and median_window_frames is None:
        median_window_frames = compute_median_window_frames(
            minutes_per_frame,
            trend_window_hours,
            T=T,
        )

    detr = preprocess_for_rhythmicity(
        trace,
        method=detrend_method,
        median_window_frames=median_window_frames,
    )

    hours_per_frame = minutes_per_frame / 60.0
    if hours_per_frame <= 0:
        return 0, np.array([], dtype=int)

    window_frames = int(round(smoothing_window_hours / hours_per_frame))
    if window_frames < 1:
        window_frames = 1
    if window_frames % 2 == 0:
        window_frames += 1

    if window_frames > 1:
        kernel = np.ones(window_frames, dtype=float) / float(window_frames)
        smooth = np.convolve(detr, kernel, mode="same")
    else:
        smooth = detr

    amp_range = float(smooth.max() - smooth.min())
    if amp_range <= 0:
        return 0, np.array([], dtype=int)

    prominence = amp_range * float(min_prominence_fraction)
    if prominence <= 0:
        prominence = amp_range * 0.1

    peaks, _ = find_peaks(smooth, prominence=prominence)
    if peaks.size == 0:
        return 0, peaks

    expected_frames = period_hours / hours_per_frame
    if expected_frames <= 0:
        return int(peaks.size), peaks

    min_dist = 0.5 * expected_frames
    max_dist = 1.5 * expected_frames

    good_peaks = []
    prev_peak = None
    for idx in peaks:
        if prev_peak is None:
            good_peaks.append(idx)
            prev_peak = idx
        else:
            d = idx - prev_peak
            if min_dist <= d <= max_dist:
                good_peaks.append(idx)
                prev_peak = idx
            elif d > max_dist:
                good_peaks.append(idx)
                prev_peak = idx
            else:
                continue

    good_peaks = np.array(good_peaks, dtype=int)
    n_cycles = max(int(good_peaks.size - 1), 0)
    return n_cycles, good_peaks

def strict_cycle_mask(
    traces_data,
    minutes_per_frame,
    period_hours,
    base_mask,
    min_cycles=2,
    detrend_method="running_median",
    median_window_frames=None,
    trend_window_hours=RHYTHM_TREND_WINDOW_HOURS,
    smoothing_window_hours=2.0,
    min_prominence_fraction=0.2,
):
    """
    Refine a base rhythmicity mask by requiring a minimum number of cycles.

    Parameters:
        traces_data : 2D array-like, shape (T, N+1)
            First column is time, remaining columns are per-cell traces.
        minutes_per_frame : float
            Sampling interval in minutes.
        period_hours : float
            Target period (e.g., 24.0 for circadian).
        base_mask : 1D boolean array, length N
            Initial rhythmicity decision per cell (e.g., Cosinor/FFT filter).
        min_cycles : int
            Minimum number of cycles required to keep a cell as "rhythmic".
        detrend_method, median_window_frames, trend_window_hours,
        smoothing_window_hours, min_prominence_fraction :
            Parameters passed through to estimate_cycle_count_from_trace.

    Returns:
        strict_mask : 1D boolean np.ndarray, length N
            Refined mask that incorporates both base_mask and cycle-count requirement.
    """
    traces_data = np.asarray(traces_data)
    base_mask = np.asarray(base_mask, dtype=bool)

    if traces_data.ndim != 2 or traces_data.shape[1] < 2:
        raise ValueError("traces_data must have shape (T, N+1).")

    T, cols = traces_data.shape
    N = cols - 1

    if base_mask.shape[0] != N:
        raise ValueError("base_mask length must equal number of cells (N).")

    strict_mask = base_mask.copy()
    if not np.any(base_mask):
        return strict_mask

    intensities = traces_data[:, 1:]

    for i in range(N):
        if not base_mask[i]:
            continue

        trace = intensities[:, i]
        n_cycles, _ = estimate_cycle_count_from_trace(
            trace,
            minutes_per_frame=minutes_per_frame,
            period_hours=period_hours,
            detrend_method=detrend_method,
            median_window_frames=median_window_frames,
            trend_window_hours=trend_window_hours,
            smoothing_window_hours=smoothing_window_hours,
            min_prominence_fraction=min_prominence_fraction,
        )

        if n_cycles < min_cycles:
            strict_mask[i] = False

    return strict_mask

def calculate_phases_fft(traces_data,
                         minutes_per_frame,
                         period_min=None,
                         period_max=None,
                         detrend_method="running_median",
                         detrend_window_frames=None,
                         detrend_window_hours=RHYTHM_TREND_WINDOW_HOURS):
    """
    Compute per-cell FFT phases and a sideband-based SNR rhythmicity score.

    Parameters:
        traces_data: 2D array of shape (T, N+1) where first column is time
                     and remaining columns are fluorescence traces.
        minutes_per_frame: float
        period_min, period_max: optional bounds on allowed periods (hours)
        detrend_method: "running_median", "polynomial", or "none"
        detrend_window_frames: int or None
            If None and detrend_method == "running_median", the window will be
            derived from minutes_per_frame and detrend_window_hours.
        detrend_window_hours: float
            Trend window width in hours for dynamic median-window computation.

    Returns:
        phases: array of shape (N,)
        period_hours: float, dominant period
        rhythm_snr_scores: array of shape (N,)
    """

    intensities = traces_data[:, 1:]        # (T, N)
    T, N = intensities.shape

    # Time  frequency mapping
    dt_hours = minutes_per_frame / 60.0
    freqs = np.fft.rfftfreq(T, d=dt_hours)

    # Choose median window in frames if needed
    if detrend_method == "running_median" and detrend_window_frames is None:
        detrend_window_frames = compute_median_window_frames(
            minutes_per_frame,
            detrend_window_hours,
            T=T,
        )

    # Detrend ALL traces before spectrum analysis
    detrended = np.zeros_like(intensities)
    for i in range(N):
        detrended[:, i] = preprocess_for_rhythmicity(
            intensities[:, i],
            method=detrend_method,
            median_window_frames=detrend_window_frames,
        )

    # Mean trace used to estimate dominant period
    mean_signal = detrended.mean(axis=1)
    fft_mean = np.fft.rfft(mean_signal)
    power_mean = np.abs(fft_mean) ** 2

    # Determine allowed frequency range for peak search
    if period_min is not None and period_max is not None:
        fmin = 1.0 / period_max
        fmax = 1.0 / period_min
        mask = (freqs >= fmin) & (freqs <= fmax)
    else:
        mask = np.ones_like(freqs, dtype=bool)

    masked_power = power_mean.copy()
    masked_power[~mask] = 0
    peak_idx = np.argmax(masked_power)
    peak_freq = freqs[peak_idx]
    period_hours = 1.0 / peak_freq if peak_freq > 0 else np.inf

    # Sideband SNR: signal band = 1 bins; noise = 10 bins outside that
    signal_band = []
    for off in (-1, 0, 1):
        idx = peak_idx + off
        if 0 <= idx < len(freqs):
            signal_band.append(idx)
    signal_band = np.array(signal_band, dtype=int)

    noise_band = []
    for off in range(2, 11):
        for sign in (-1, +1):
            idx = peak_idx + sign * off
            if 0 <= idx < len(freqs):
                noise_band.append(idx)
    noise_band = np.array(noise_band, dtype=int)

    phases = np.zeros(N)
    rhythm_snr_scores = np.zeros(N)

    for i in range(N):
        trace = detrended[:, i]
        fft_vals = np.fft.rfft(trace)
        power_vals = np.abs(fft_vals) ** 2

        complex_val = fft_vals[peak_idx]
        phases[i] = -np.angle(complex_val)

        signal_power = power_vals[signal_band].sum()
        noise_power = power_vals[noise_band].mean() if len(noise_band) > 0 else 1e-9
        snr = signal_power / (noise_power + 1e-9)
        rhythm_snr_scores[i] = snr

    return phases, period_hours, rhythm_snr_scores


================================================================
File: gui\main_window.py
================================================================
import os
import sys
import json
import numpy as np
from PyQt5 import QtWidgets, QtCore

from gui.state import AnalysisState
from gui.utils import Tooltip, clear_layout
from gui.theme import get_icon
from gui.panels.single_animal import SingleAnimalPanel
from gui.panels.atlas_registration import AtlasRegistrationPanel
from gui.panels.apply_warp import ApplyWarpPanel
from gui.panels.group_view import GroupViewPanel

class MainWindow(QtWidgets.QMainWindow):
    """
    PyQt main window implementing the full original workflow.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Neuron Analysis Workspace")
        self.resize(1400, 900)

        # Centralized state object
        self.state = AnalysisState()

        self.visualization_widgets = {}

        self.workflow_state = {
            "has_input": False,
            "has_results": False,
            "has_anatomical_roi": False,
            "has_warp": False,
            "has_group_data": False,
        }

        self._build_ui()
        self._build_menu()
        self._build_toolbar()
        
        # Initialize panels
        self.single_panel = SingleAnimalPanel(self)
        self.register_panel = AtlasRegistrationPanel(self)
        self.apply_panel = ApplyWarpPanel(self)
        self.group_panel = GroupViewPanel(self)
        
        self.mode_stack.addWidget(self.single_panel)
        self.mode_stack.addWidget(self.register_panel)
        self.mode_stack.addWidget(self.apply_panel)
        self.mode_stack.addWidget(self.group_panel)

    def _build_ui(self):
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)

        # Main Splitter (Left: Controls, Right: Vis)
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(self.splitter, 1)
        
        # --- Left Side: Navigation & Controls ---
        left_widget = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        self.splitter.addWidget(left_widget)
        
        # 1. Navigation List (Replaces Workflow & Active Panel)
        self._build_navigation_section(left_layout)
        
        # 2. Scrollable Control Area (For specific panel content)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QtWidgets.QFrame.NoFrame)
        left_layout.addWidget(scroll, 1) # Takes remaining space
        
        self.ctrl_container = QtWidgets.QWidget()
        self.ctrl_layout = QtWidgets.QVBoxLayout(self.ctrl_container)
        self.ctrl_layout.setContentsMargins(0, 0, 0, 0)
        scroll.setWidget(self.ctrl_container)
        
        # Stacked Widget for Panels
        self.mode_stack = QtWidgets.QStackedWidget()
        self.ctrl_layout.addWidget(self.mode_stack)
        
        # Execution Box (Shared controls) - Kept in scroll area or pinned to bottom of left?
        # Let's pin it to the bottom of the scroll content for now.
        exec_box = QtWidgets.QGroupBox("Global Actions")
        exec_layout = QtWidgets.QVBoxLayout(exec_box)
        
        hbox_run = QtWidgets.QHBoxLayout()
        self.btn_run_analysis = QtWidgets.QPushButton(get_icon('fa5s.play'), "Run Analysis")
        Tooltip.install(self.btn_run_analysis, "Run full pipeline on loaded movie.")
        self.btn_run_analysis.setEnabled(False)
        
        self.btn_load_results = QtWidgets.QPushButton(get_icon('fa5s.folder-open'), "Load Results")
        self.btn_load_results.setEnabled(False)
        hbox_run.addWidget(self.btn_run_analysis)
        hbox_run.addWidget(self.btn_load_results)
        
        hbox_export = QtWidgets.QHBoxLayout()
        self.btn_export_data = QtWidgets.QPushButton(get_icon('fa5s.file-csv'), "Export Data")
        self.btn_export_data.setEnabled(False)
        
        self.btn_export_plot = QtWidgets.QPushButton(get_icon('fa5s.image'), "Export Plot")
        self.btn_export_plot.setEnabled(False)
        hbox_export.addWidget(self.btn_export_data)
        hbox_export.addWidget(self.btn_export_plot)
        
        exec_layout.addLayout(hbox_run)
        exec_layout.addLayout(hbox_export)
        self.ctrl_layout.addWidget(exec_box)
        self.ctrl_layout.addStretch(1)

        # --- Right Side: Visualizations ---
        right_widget = QtWidgets.QWidget()
        right_layout = QtWidgets.QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        self.splitter.addWidget(right_widget)
        
        self.vis_tabs = QtWidgets.QTabWidget()
        right_layout.addWidget(self.vis_tabs)
        
        # --- Bottom: Log and Progress ---
        bottom_widget = QtWidgets.QWidget()
        bottom_layout = QtWidgets.QVBoxLayout(bottom_widget)
        bottom_layout.setContentsMargins(0, 0, 0, 0)
        
        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setFixedHeight(5) # Slim progress bar
        bottom_layout.addWidget(self.progress_bar)

        self.log_text = QtWidgets.QPlainTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMaximumHeight(100) # Limit log height
        self.log_text.setPlaceholderText("Execution log...")
        bottom_layout.addWidget(self.log_text)
        
        main_layout.addWidget(bottom_widget, 0)
        
        # Splitter Ratios
        self.splitter.setStretchFactor(0, 1) # Left
        self.splitter.setStretchFactor(1, 3) # Right
        
        self._build_vis_tabs()

    def _build_toolbar(self):
        toolbar = QtWidgets.QToolBar("Main Toolbar")
        toolbar.setIconSize(QtCore.QSize(20, 20))
        toolbar.setMovable(False)
        self.addToolBar(toolbar)
        
        open_act = QtWidgets.QAction(get_icon('fa5s.folder-open'), "Open Project", self)
        open_act.triggered.connect(self.load_project)
        toolbar.addAction(open_act)
        
        save_act = QtWidgets.QAction(get_icon('fa5s.save'), "Save Project", self)
        save_act.triggered.connect(self.save_project)
        toolbar.addAction(save_act)

    def _build_vis_tabs(self):
        self.heatmap_tab = QtWidgets.QWidget()
        self.com_tab = QtWidgets.QWidget()
        self.traj_tab = QtWidgets.QWidget()
        self.phase_tab = QtWidgets.QWidget()
        self.interp_tab = QtWidgets.QWidget()
        self.group_scatter_tab = QtWidgets.QWidget()
        self.group_avg_tab = QtWidgets.QWidget()
        
        tabs_to_add = [
            (self.heatmap_tab, "Heatmap"),
            (self.com_tab, "CoM"),
            (self.traj_tab, "Trajectories"),
            (self.phase_tab, "Phase Map"),
            (self.interp_tab, "Interp Map"),
            (self.group_scatter_tab, "Grp Scatter"),
            (self.group_avg_tab, "Grp Avg Map"),
        ]
        
        for tab, name in tabs_to_add:
            self.vis_tabs.addTab(tab, name)
            layout = QtWidgets.QVBoxLayout(tab)
            label = QtWidgets.QLabel(
                f"{name} will appear here after analysis."
            )
            label.setAlignment(QtCore.Qt.AlignCenter)
            layout.addWidget(label)
        
        for i in range(self.vis_tabs.count()):
            self.vis_tabs.setTabEnabled(i, False)

    def _build_navigation_section(self, parent_layout):
        """Builds the navigation list acting as both workflow guide and panel switcher."""
        self.nav_list = QtWidgets.QListWidget()
        self.nav_list.setFixedHeight(120) # Compact fixed height
        self.nav_list.setIconSize(QtCore.QSize(24, 24))
        self.nav_list.setStyleSheet("""
            QListWidget {
                background-color: #f0f0f0;
                border: 1px solid #d0d0d0;
                border-radius: 4px;
            }
            QListWidget::item {
                padding: 5px;
            }
            QListWidget::item:selected {
                background-color: #ffffff;
                color: #007acc;
                border-left: 4px solid #007acc;
            }
        """)
        
        items = [
            ("single", "1. Single Animal Analysis", "fa5s.paw"),
            ("register", "2. Atlas Registration", "fa5s.map"),
            ("apply_warp", "3. Apply Warp", "fa5s.dna"),
            ("group_view", "4. Group Analysis", "fa5s.users"),
        ]
        
        for key, text, icon_name in items:
            item = QtWidgets.QListWidgetItem(get_icon(icon_name), text)
            item.setData(QtCore.Qt.UserRole, key)
            self.nav_list.addItem(item)
            
        self.nav_list.currentItemChanged.connect(self._on_nav_item_changed)
        parent_layout.addWidget(self.nav_list)

    def _on_nav_item_changed(self, current, previous):
        if not current:
            return
        mode_key = current.data(QtCore.Qt.UserRole)
        self._switch_mode(mode_key)

    def _build_menu(self):
        menu_bar = self.menuBar()
        file_menu = menu_bar.addMenu("&File")

        open_action = QtWidgets.QAction("&Open Project...", self)
        open_action.triggered.connect(self.load_project)
        file_menu.addAction(open_action)

        save_action = QtWidgets.QAction("&Save Project", self)
        save_action.triggered.connect(self.save_project)
        file_menu.addAction(save_action)

        save_as_action = QtWidgets.QAction("Save Project &As...", self)
        save_as_action.triggered.connect(lambda: self.save_project(save_as=True))
        file_menu.addAction(save_as_action)

    def _switch_mode(self, mode_name: str):
        mode_map = {
            "single": 0, "register": 1, "apply_warp": 2, "group_view": 3,
        }
        idx = mode_map.get(mode_name)
        if idx is not None:
            self.mode_stack.setCurrentIndex(idx)
            # Ensure list selection matches (in case called programmatically)
            for i in range(self.nav_list.count()):
                item = self.nav_list.item(i)
                if item.data(QtCore.Qt.UserRole) == mode_name:
                    self.nav_list.setCurrentItem(item)
                    break
            self.log_message(f"Switched to '{mode_name}' panel.")
        else:
            self.log_message(f"Error: Unknown mode '{mode_name}'")

    def _set_mode_enabled(self, mode_key, enabled: bool):
        # In the list widget, we can disable items or just visually dim them.
        # For now, let's just keep them enabled but maybe change icon color if we wanted.
        # Standard QListWidgetItem doesn't have setEnabled in a way that blocks selection easily without flags.
        for i in range(self.nav_list.count()):
            item = self.nav_list.item(i)
            if item.data(QtCore.Qt.UserRole) == mode_key:
                if enabled:
                    item.setFlags(item.flags() | QtCore.Qt.ItemIsEnabled)
                else:
                    item.setFlags(item.flags() & ~QtCore.Qt.ItemIsEnabled)
                break

    def _mark_step_ready(self, mode_key):
        for i in range(self.nav_list.count()):
            item = self.nav_list.item(i)
            if item.data(QtCore.Qt.UserRole) == mode_key:
                # Add a checkmark or change color to indicate readiness
                item.setIcon(get_icon('fa5s.check-circle', color='#2e7d32')) # Green check
                break

    def log_message(self, text: str):
        self.log_text.appendPlainText(text)
        self.log_text.verticalScrollBar().setValue(
            self.log_text.verticalScrollBar().maximum()
        )

    def _get_last_dir(self):
        settings = QtCore.QSettings()
        return settings.value("last_dir", "")

    def _set_last_dir(self, path):
        if not path:
            return
        settings = QtCore.QSettings()
        directory = os.path.dirname(path) if os.path.isfile(path) else path
        settings.setValue("last_dir", directory)

    def _reset_state(self):
        self.log_message("Resetting workspace for new analysis...")
        self.state.reset()
        
        # Reset panel-specific states
        if hasattr(self, 'single_panel'):
            self.single_panel.reset_state()
            
        self.visualization_widgets.clear()
        for i in range(self.vis_tabs.count()):
            tab = self.vis_tabs.widget(i)
            layout = tab.layout()
            if layout is not None:
                clear_layout(layout)
            else:
                layout = QtWidgets.QVBoxLayout(tab)
            label = QtWidgets.QLabel(
                f"{self.vis_tabs.tabText(i)} will appear here after analysis."
            )
            label.setAlignment(QtCore.Qt.AlignCenter)
            layout.addWidget(label)
            self.vis_tabs.setTabEnabled(i, False)
            
        self.btn_run_analysis.setEnabled(False)
        self.btn_load_results.setEnabled(False)
        self.btn_export_plot.setEnabled(False)
        self.btn_export_data.setEnabled(False)
        self.progress_bar.setValue(0)

    def update_workflow_from_files(self):
        basename = self.state.output_basename
        if not basename:
            return
        input_present = bool(self.state.input_movie_path)
        if input_present:
            self.workflow_state["has_input"] = True
            self._mark_step_ready("single")
            self.btn_run_analysis.setEnabled(True)
        
        traces_path = f"{basename}_traces.csv"
        roi_path = f"{basename}_roi.csv"
        traj_path = f"{basename}_trajectories.npy"
        has_traces = os.path.exists(traces_path)
        has_roi = os.path.exists(roi_path)
        has_traj = os.path.exists(traj_path)
        
        if hasattr(self, 'single_panel'):
            self.single_panel.status_traces_label.setText(f"Traces: {'found' if has_traces else 'missing'}")
            self.single_panel.status_roi_label.setText(f"ROI: {'found' if has_roi else 'missing'}")
            self.single_panel.status_traj_label.setText(f"Trajectories: {'found' if has_traj else 'missing'}")
        
        has_results = has_traces and has_roi and has_traj
        self.workflow_state["has_results"] = has_results
        self.btn_load_results.setEnabled(has_results)
        
        if has_results:
            self._mark_step_ready("single")
            self._set_mode_enabled("register", True)
            if hasattr(self, 'single_panel'):
                self.single_panel.btn_define_roi.setEnabled(True)
                self.single_panel.btn_regen_phase.setEnabled(True)
                self.btn_export_plot.setEnabled(True)
                
        anatomical_roi_path = f"{basename}_anatomical_roi.json"
        has_anatomical_roi = os.path.exists(anatomical_roi_path)
        self.workflow_state["has_anatomical_roi"] = has_anatomical_roi
        if has_anatomical_roi:
            self._mark_step_ready("register")
            self._set_mode_enabled("register", True)
            self._set_mode_enabled("apply_warp", True)
            
        dirname = os.path.dirname(basename) or "."
        warp_files = [f for f in os.listdir(dirname) if f.endswith("_warp_parameters.json")]
        warped_roi_files = [f for f in os.listdir(dirname) if f.endswith("_roi_warped.csv")]
        has_warp = len(warp_files) > 0
        has_group = len(warped_roi_files) > 0
        self.workflow_state["has_warp"] = has_warp
        self.workflow_state["has_group_data"] = has_group
        
        if has_warp:
            self._mark_step_ready("apply_warp")
            self._set_mode_enabled("apply_warp", True)
        if has_group:
            self._mark_step_ready("group_view")
            self._set_mode_enabled("group_view", True)
            if hasattr(self, 'group_panel'):
                self.group_panel.btn_view_group.setEnabled(True)

    def save_project(self, save_as=False):
        project_path = self.state.project_path
        if not project_path or save_as:
            start_dir = self._get_last_dir()
            path, _ = QtWidgets.QFileDialog.getSaveFileName(
                self, "Save Project", start_dir, "Neuron Tracker Project (*.ntp)"
            )
            if not path:
                return
            project_path = path
        
        try:
            self._sync_state_from_ui()
            state_to_save = {
                'atlas_roi_path': self.state.atlas_roi_path,
                'target_roi_paths': self.state.target_roi_paths,
                'warp_param_paths': self.state.warp_param_paths,
                'group_data_paths': self.state.group_data_paths,
            }
            with open(project_path, 'w') as f:
                json.dump(state_to_save, f, indent=4)
            
            self._set_last_dir(project_path)
            self.state.project_path = project_path
            self.log_message(f"Project saved to {os.path.basename(self.state.project_path)}")
            self.setWindowTitle(f"{os.path.basename(self.state.project_path)} - Neuron Analysis Workspace")

        except Exception as e:
            self.log_message(f"Error saving project: {e}")

    def load_project(self):
        start_dir = self._get_last_dir()
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Open Project", start_dir, "Neuron Tracker Project (*.ntp)"
        )
        if not path:
            return
        
        self._set_last_dir(path)
        self._reset_state()
        
        try:
            with open(path, 'r') as f:
                loaded_state = json.load(f)
            
            self.state.project_path = path
            self.state.atlas_roi_path = loaded_state.get('atlas_roi_path', "")
            self.state.target_roi_paths = loaded_state.get('target_roi_paths', [])
            self.state.warp_param_paths = loaded_state.get('warp_param_paths', [])
            self.state.group_data_paths = loaded_state.get('group_data_paths', [])
            
            self.log_message(f"Loaded project: {os.path.basename(path)}")
            self._update_ui_from_state()
            self.setWindowTitle(f"{os.path.basename(path)} - Neuron Analysis Workspace")

        except Exception as e:
            self.log_message(f"Error loading project: {e}")

    def _update_ui_from_state(self):
        if hasattr(self, 'register_panel'):
            self.register_panel.atlas_path_edit.setText(self.state.atlas_roi_path)
            self.register_panel.target_list.clear()
            self.register_panel.target_list.addItems(self.state.target_roi_paths)
            self.register_panel._update_reg_button_state()
            
        if hasattr(self, 'apply_panel'):
            self.apply_panel.warp_list.clear()
            self.apply_panel.warp_list.addItems(self.state.warp_param_paths)
            self.apply_panel.check_apply_warp_buttons_state()
            
        if hasattr(self, 'group_panel'):
            self.group_panel.group_list.clear()
            self.group_panel.group_list.addItems(self.state.group_data_paths)
            self.group_panel._update_group_view_button()
            
        self.log_message("UI updated from loaded project.")

    def _sync_state_from_ui(self):
        if hasattr(self, 'register_panel'):
            self.state.atlas_roi_path = self.register_panel.atlas_path_edit.text()
            self.state.target_roi_paths = [self.register_panel.target_list.item(i).text() for i in range(self.register_panel.target_list.count())]
            
        if hasattr(self, 'apply_panel'):
            self.state.warp_param_paths = [self.apply_panel.warp_list.item(i).text() for i in range(self.apply_panel.warp_list.count())]
            
        if hasattr(self, 'group_panel'):
            self.state.group_data_paths = [self.group_panel.group_list.item(i).text() for i in range(self.group_panel.group_list.count())]
            
        self.log_message("Internal state synchronized from UI.")


================================================================
File: gui\state.py
================================================================
# gui/state.py
class AnalysisState:
    """A simple class to hold all application state."""
    def __init__(self):
        self.reset()

    def reset(self):
        # File paths
        self.project_path = "" # Path to the .ntp project file
        self.input_movie_path = ""
        self.output_basename = ""
        self.atlas_roi_path = ""
        self.reference_roi_path = ""
        
        # Lists for workflow panels
        self.target_roi_paths = []
        self.warp_param_paths = []
        self.group_data_paths = []
        
        # In-memory data
        self.unfiltered_data = {}
        self.loaded_data = {}

        # Group Comparison State 
        self.reference_grid_def = None  
        self.reference_raw_data = None

================================================================
File: gui\statistics.py
================================================================
# gui/statistics.py
import numpy as np
from scipy.stats import circmean

def circmean_hours(phases, period):
    """
    Circular mean of phases given in hours.
    Returns mean in hours on the same scale [0, period].
    """
    phases = np.asarray(phases, dtype=float)
    if phases.size == 0:
        return np.nan
    
    # Convert to radians [-pi, pi]
    # (Phase / Period) * 2pi
    angles = phases * (2 * np.pi / period)
    
    # Calculate circular mean in radians
    mean_angle = circmean(angles, low=-np.pi, high=np.pi)
    
    # Convert back to hours
    return mean_angle * (period / (2 * np.pi))

def watson_williams_f(group_a, group_b):
    """
    Watson-Williams F-test for two circular samples.
    Input: Arrays of phases in Hours.
    Assumption: Period is 24.0 hours (standard for group analysis).
    Returns: F-statistic (float).
    """
    a = np.asarray(group_a)
    b = np.asarray(group_b)
    
    n1 = len(a)
    n2 = len(b)
    N = n1 + n2
    
    if n1 == 0 or n2 == 0:
        return 0.0

    # Convert hours to radians (Assumes Period=24.0)
    period = 24.0 
    rad_a = a * (2 * np.pi / period)
    rad_b = b * (2 * np.pi / period)
    
    # Calculate resultant vectors
    R1 = np.abs(np.sum(np.exp(1j * rad_a)))
    R2 = np.abs(np.sum(np.exp(1j * rad_b)))
    
    combined = np.concatenate([rad_a, rad_b])
    R = np.abs(np.sum(np.exp(1j * combined)))
    
    # Watson-Williams Formula
    numerator = (N - 2) * (R1 + R2 - R)
    denominator = (N - (R1 + R2))
    
    if denominator < 1e-9:
        return 0.0
    
    f_val = numerator / denominator
    return max(0, f_val)

================================================================
File: gui\theme.py
================================================================
from PyQt5 import QtGui, QtWidgets, QtCore
import qtawesome as qta
import matplotlib.pyplot as plt

def apply_theme(app):
    """
    Applies a modern, clean Light Theme to the QApplication using the Fusion style.
    This provides a softer, more standard desktop application appearance.
    """
    app.setStyle("Fusion")

    # Define the Light Palette
    window_bg = QtGui.QColor(245, 245, 247)   # Very light gray (macOS-like)
    base_color = QtGui.QColor(255, 255, 255)  # White for inputs/lists
    text_color = QtGui.QColor(33, 33, 33)     # Dark gray for text (softer than pure black)
    btn_color = QtGui.QColor(235, 235, 235)   # Light gray for buttons
    accent_color = QtGui.QColor(0, 122, 204)  # Professional Blue accent
    highlight_color = QtGui.QColor(0, 120, 215) # Standard selection blue

    palette = QtGui.QPalette()
    
    # Window & Backgrounds
    palette.setColor(QtGui.QPalette.Window, window_bg)
    palette.setColor(QtGui.QPalette.WindowText, text_color)
    palette.setColor(QtGui.QPalette.Base, base_color)
    palette.setColor(QtGui.QPalette.AlternateBase, window_bg)
    palette.setColor(QtGui.QPalette.ToolTipBase, base_color)
    palette.setColor(QtGui.QPalette.ToolTipText, text_color)
    palette.setColor(QtGui.QPalette.Text, text_color)
    
    # Buttons
    palette.setColor(QtGui.QPalette.Button, btn_color)
    palette.setColor(QtGui.QPalette.ButtonText, text_color)
    palette.setColor(QtGui.QPalette.BrightText, QtCore.Qt.red)
    
    # Links & Highlights
    palette.setColor(QtGui.QPalette.Link, accent_color)
    palette.setColor(QtGui.QPalette.Highlight, highlight_color)
    palette.setColor(QtGui.QPalette.HighlightedText, QtCore.Qt.white)

    # Disabled states
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, QtGui.QColor(170, 170, 170))
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, QtGui.QColor(170, 170, 170))
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Button, QtGui.QColor(240, 240, 240))

    app.setPalette(palette)

    # Set a modern standard font
    font = QtGui.QFont("Segoe UI", 10)
    font.setStyleStrategy(QtGui.QFont.PreferAntialias)
    app.setFont(font)
    
    # Additional Stylesheet for softer UI elements
    app.setStyleSheet(f"""
        QToolTip {{ 
            color: #212121; 
            background-color: #ffffff; 
            border: 1px solid #cccccc; 
        }}
        QGroupBox {{ 
            border: 1px solid #d0d0d0; 
            margin-top: 1.5em; 
            border-radius: 6px;
            background-color: #ffffff;
            padding-top: 10px;
        }}
        QGroupBox::title {{ 
            subcontrol-origin: margin; 
            subcontrol-position: top left; 
            padding: 0 5px; 
            color: #007acc; /* Blue title */
            font-weight: bold;
        }}
        QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox {{
            border: 1px solid #c0c0c0;
            border-radius: 4px;
            padding: 4px;
            background-color: #ffffff;
            selection-background-color: #0078d7;
        }}
        QLineEdit:focus, QComboBox:focus {{
            border: 1px solid #0078d7;
        }}
        QPushButton {{
            background-color: #ffffff;
            border: 1px solid #c0c0c0;
            border-radius: 5px;
            padding: 6px 12px;
            min-width: 60px;
            color: #333333;
        }}
        QPushButton:hover {{
            background-color: #f0f8ff; /* AliceBlue hover */
            border: 1px solid #0078d7;
        }}
        QPushButton:pressed {{
            background-color: #e0e0e0;
        }}
        QPushButton:disabled {{
            background-color: #f5f5f5;
            border: 1px solid #e0e0e0;
            color: #a0a0a0;
        }}
        QListWidget {{
            background-color: #ffffff;
            border: 1px solid #c0c0c0;
            border-radius: 4px;
        }}
        QTabWidget::pane {{ 
            border: 1px solid #d0d0d0;
            background: #ffffff;
            border-radius: 4px;
        }}
        QTabBar::tab {{
            background: #e0e0e0;
            border: 1px solid #c0c0c0;
            padding: 4px 8px;
            margin-right: 2px;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            color: #555555;
        }}
        QTabBar::tab:selected {{
            background: #ffffff;
            border-bottom-color: #ffffff; /* Blend with pane */
            color: #000000;
            font-weight: bold;
        }}
        QTabBar::tab:hover {{
            background: #f0f0f0;
        }}
    """)

def setup_matplotlib_theme():
    """Configures Matplotlib to look good with the light theme."""
    # Reset to defaults first to clear dark theme settings
    plt.rcdefaults()
    
    # Use a clean style
    try:
        plt.style.use('seaborn-v0_8-whitegrid')
    except OSError:
        # Fallback if seaborn style isn't available
        plt.style.use('fast')
        plt.grid(True, alpha=0.3)

    # Custom tweaks for the app
    plt.rcParams.update({
        "figure.facecolor": "#f5f5f7", # Match window bg
        "axes.facecolor": "#ffffff",
        "savefig.facecolor": "#f5f5f7",
        "axes.edgecolor": "#333333",
        "axes.labelcolor": "#333333",
        "xtick.color": "#333333",
        "ytick.color": "#333333",
        "text.color": "#333333",
        "grid.color": "#e0e0e0",
        "grid.alpha": 0.7,
        "lines.linewidth": 1.5,
        "font.size": 10,
        "figure.autolayout": False,
        # Professional color cycle
        "axes.prop_cycle": plt.cycler(color=["#007acc", "#d62728", "#2ca02c", "#ff7f0e", "#9467bd"]),
    })

def get_icon(name, color='#444444'):
    """Wrapper to get qtawesome icons. Default color is now dark for light theme."""
    return qta.icon(name, color=color)


================================================================
File: gui\utils.py
================================================================
import os
import numpy as np
from PyQt5 import QtWidgets, QtCore, QtGui

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar,
)


class AspectRatioWidget(QtWidgets.QWidget):
    """
    A widget that maintains a square (1:1) aspect ratio for its content.
    """
    def __init__(self, widget, parent=None):
        super().__init__(parent)
        self.aspect_ratio = 1.0
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(widget)
        self.widget = widget

    def resizeEvent(self, event):
        super().resizeEvent(event)
        # Calculate size that maintains aspect ratio
        w = event.size().width()
        h = event.size().height()
        
        if w / h > self.aspect_ratio:
            # Width is limiting factor
            new_h = h
            new_w = int(h * self.aspect_ratio)
        else:
            # Height is limiting factor
            new_w = w
            new_h = int(w / self.aspect_ratio)
        
        # Center the widget
        x = (w - new_w) // 2
        y = (h - new_h) // 2
        self.widget.setGeometry(x, y, new_w, new_h)


# ------------------------------------------------------------
# Tooltip Helper
# ------------------------------------------------------------
class Tooltip(QtCore.QObject):
    """A custom tooltip that can be styled and supports rich text."""
    _instance = None

    def __init__(self, parent=None):
        super().__init__(parent)
        self._label = QtWidgets.QLabel(
            None,
            flags=QtCore.Qt.ToolTip | QtCore.Qt.BypassWindowManagerHint,
        )
        self._label.setWindowOpacity(0.95)
        self._label.setStyleSheet("""
            QLabel {
                border: 1px solid #555;
                padding: 5px;
                background-color: #ffffe0; /* Light yellow */
                color: #000;
                border-radius: 3px;
            }
        """)
        self._label.setWordWrap(True)
        self._label.setAlignment(QtCore.Qt.AlignLeft)
        self._timer = QtCore.QTimer(self, singleShot=True)
        self._timer.setInterval(750)  # ms delay
        self._timer.timeout.connect(self._show)
        self._text = ""

    def _show(self):
        if not self._text:
            return
        self._label.setText(self._text)
        self._label.adjustSize()
        pos = QtGui.QCursor.pos()
        x = pos.x() + 20
        y = pos.y() + 20
        
        screen_geo = QtWidgets.QApplication.desktop().availableGeometry(pos)
        if x + self._label.width() > screen_geo.right():
            x = pos.x() - self._label.width() - 20
        if y + self._label.height() > screen_geo.bottom():
            y = pos.y() - self._label.height() - 20
            
        self._label.move(x, y)
        self._label.show()

    def show_tooltip(self, text):
        self._text = text
        self._timer.start()

    def hide_tooltip(self):
        self._timer.stop()
        self._label.hide()

    @classmethod
    def install(cls, widget, text):
        if cls._instance is None:
            # Ensure the instance has a parent to be properly managed
            parent = widget.window() if widget.window() else QtWidgets.QApplication.instance()
            cls._instance = cls(parent)
        
        widget.setMouseTracking(True)
        
        class Filter(QtCore.QObject):
            def eventFilter(self, obj, event):
                if obj == widget:
                    if event.type() == QtCore.QEvent.Enter:
                        cls._instance.show_tooltip(text)
                    elif event.type() == QtCore.QEvent.Leave:
                        cls._instance.hide_tooltip()
                return False

        if not hasattr(widget, '_tooltip_filter'):
            widget._tooltip_filter = Filter(widget)
            widget.installEventFilter(widget._tooltip_filter)

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

def clear_layout(layout: QtWidgets.QLayout):
    """Remove all widgets/items from a layout without replacing the layout object."""
    if layout is None:
        return
    while layout.count():
        item = layout.takeAt(0)
        w = item.widget()
        if w is not None:
            w.setParent(None)


def add_mpl_to_tab(tab: QtWidgets.QWidget):
    """
    Ensure the tab has a QVBoxLayout, clear it, and add a FigureCanvas+Toolbar.
    Returns (fig, canvas).
    """
    layout = tab.layout()
    if layout is None:
        layout = QtWidgets.QVBoxLayout(tab)
        layout.setContentsMargins(4, 4, 4, 4)
    clear_layout(layout)

    # Create figure with square aspect ratio for consistency
    fig = Figure(figsize=(8, 8))
    canvas = FigureCanvas(fig)
    toolbar = NavigationToolbar(canvas, tab)

    layout.addWidget(toolbar)
    layout.addWidget(canvas, 1)

    return fig, canvas

def project_points_to_polyline(points, polyline):
    """
    Projects 2D points onto a multi-segment polyline.
    Returns the normalized arc-length position 's' [0.0, 1.0] for each point.
    
    Args:
        points (Nx2 array): Cell coordinates.
        polyline (Mx2 array): Ordered vertices of the Phase Axis.
        
    Returns:
        s (N array): Position along the curve (0=Start, 1=End).
    """
    points = np.asarray(points)
    polyline = np.asarray(polyline)
    
    if len(polyline) < 2:
        return np.zeros(len(points))
        
    # 1. Calculate segment lengths and total length
    # diffs = P[i+1] - P[i]
    seg_vecs = np.diff(polyline, axis=0)
    seg_lens = np.linalg.norm(seg_vecs, axis=1)
    total_len = np.sum(seg_lens)
    
    # Cumulative length at each vertex [0, L1, L1+L2, ...]
    cum_len = np.concatenate(([0], np.cumsum(seg_lens)))
    
    s_values = []
    
    for p in points:
        best_dist = np.inf
        best_s = 0.0
        
        # Check each segment
        for i in range(len(seg_vecs)):
            # Segment from A to B
            A = polyline[i]
            B = polyline[i+1]
            vec_AB = seg_vecs[i]
            len_AB = seg_lens[i]
            
            if len_AB == 0: continue
                
            # Vector from A to Point
            vec_AP = p - A
            
            # Project AP onto AB (t = dot(AP, AB) / |AB|^2)
            t = np.dot(vec_AP, vec_AB) / (len_AB**2)
            
            # Clamp t to segment [0, 1]
            t_clamped = np.clip(t, 0.0, 1.0)
            
            # Closest point on segment
            closest = A + t_clamped * vec_AB
            dist = np.linalg.norm(p - closest)
            
            if dist < best_dist:
                best_dist = dist
                # Calculate absolute distance along the whole polyline
                abs_pos = cum_len[i] + (t_clamped * len_AB)
                best_s = abs_pos / total_len
                
        s_values.append(best_s)
        
    return np.array(s_values)

================================================================
File: gui\viewers.py
================================================================
import numpy as np
import pandas as pd
import colorcet as cet
from scipy.interpolate import RBFInterpolator
from scipy.spatial import ConvexHull
from numpy import pi, arctan2
from scipy.stats import circmean, linregress, sem

from PyQt5 import QtWidgets, QtCore, QtGui

from matplotlib.widgets import Slider, RadioButtons, Button, CheckButtons
from matplotlib.patches import Polygon, Rectangle
from matplotlib.patches import Polygon as MplPolygon
from matplotlib.path import Path
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar,
)
import matplotlib.cm as cm
import matplotlib.colors as mcolors

import cosinor as csn
from gui.analysis import compute_median_window_frames, preprocess_for_rhythmicity

# ------------------------------------------------------------
# Visualization Viewers
# ------------------------------------------------------------

class HeatmapViewer:
    def __init__(self, fig, loaded_data, filtered_indices, phases, rhythm_scores, is_emphasized, rhythm_sort_desc, 
                 period=None, minutes_per_frame=None, reference_phase=None, trend_window_hours=None):
        self.fig = fig
        self.loaded_data = loaded_data
        self.traces_data = loaded_data["traces"]
        self.roi_data = loaded_data["roi"]
        self.filtered_indices = filtered_indices
        self.is_emphasized = is_emphasized
        self.rhythm_mask = None
        self.emphasis_overlay = None
        self.rhythm_sort_desc = rhythm_sort_desc
        self.last_sort_indices = np.arange(len(self.roi_data))
        
        self.current_selected_index = None 
        
        self.period = period
        self.minutes_per_frame = minutes_per_frame
        self.reference_phase = reference_phase
        self.trend_window_hours = trend_window_hours or 36.0

        gs = self.fig.add_gridspec(2, 1, height_ratios=[3, 1], hspace=0.45) 
        self.ax_heatmap = self.fig.add_subplot(gs[0])
        self.ax_trace = self.fig.add_subplot(gs[1])
        
        self._prepare_normalized_data()
        
        self.image_artist = self.ax_heatmap.imshow(self.normalized_data.T, aspect="auto", cmap="viridis", interpolation="nearest")
        self.ax_heatmap.set_title("Intensity Heatmap")
        self.cbar = self.fig.colorbar(self.image_artist, ax=self.ax_heatmap, label="Normalized Intensity")

        ax_radio = self.fig.add_axes([0.01, 0.7, 0.15, 0.15])
        sort_options = ["Y-coordinate", "Phase", "Rhythmicity"]
        if phases is None: sort_options.remove("Phase")
        if rhythm_scores is None: sort_options.remove("Rhythmicity")
        
        self.radio_buttons = RadioButtons(ax_radio, sort_options)
        self.radio_buttons.on_clicked(self.on_sort_change)
        
        self.ax_trace.set_xlabel("Time (frames)")
        self.ax_trace.set_ylabel("Detrended Intensity")
        self.ax_trace.set_title("Selected Cell Trace")
        
        self.trace_line = self.ax_trace.plot([], [], 'b-', alpha=0.6, label="Data")[0]
        self.fit_line = self.ax_trace.plot([], [], 'r-', linewidth=2, label="Fit")[0]
        self.ax_trace.legend(loc="upper right", fontsize="small")

        if rhythm_scores is not None:
            try:
                main_win = self.fig.canvas.parent().window()
                thr = float(main_win.phase_params["rhythm_threshold"][0].text())
            except:
                thr = 0.0
            if self.rhythm_sort_desc: self.rhythm_mask = rhythm_scores >= thr
            else: self.rhythm_mask = rhythm_scores <= thr
        
        self.update_phase_data(phases, rhythm_scores, self.rhythm_mask, self.rhythm_sort_desc, 
                               period, minutes_per_frame, reference_phase, trend_window_hours)
        
        if sort_options: self.on_sort_change(sort_options[0])

    def _prepare_normalized_data(self):
        intensities = self.traces_data[:, 1:]
        if intensities.size == 0: self.normalized_data = np.zeros((1, 1)); return
        mins, maxs = intensities.min(axis=0), intensities.max(axis=0)
        denom = maxs - mins; denom[denom == 0] = 1
        self.normalized_data = (intensities - mins) / denom

    def on_sort_change(self, label):
        if self.normalized_data.size == 0: return
        sort_values = self.sort_values.get(label)
        if sort_values is None: return
        is_descending = self.rhythm_sort_desc if label == "Rhythmicity" else False
        if is_descending: sort_values = -sort_values
        if self.is_emphasized and self.rhythm_mask is not None:
            final_indices = np.lexsort((sort_values, ~self.rhythm_mask))
        else:
            final_indices = np.argsort(sort_values)
        self.image_artist.set_data(self.normalized_data[:, final_indices].T)
        self.ax_heatmap.set_ylabel(f"Cells (sorted by {label})")
        if self.emphasis_overlay: self.emphasis_overlay.remove(); self.emphasis_overlay = None
        if self.is_emphasized and self.rhythm_mask is not None:
            num_rhythmic = np.sum(self.rhythm_mask)
            total_cells = len(self.rhythm_mask)
            if num_rhythmic < total_cells:
                height = total_cells - num_rhythmic
                y_start = num_rhythmic - 0.5 
                self.emphasis_overlay = Rectangle(xy=(-0.5, y_start), width=self.normalized_data.shape[0], height=height, facecolor='black', alpha=0.6, edgecolor='none', zorder=10)
                self.ax_heatmap.add_patch(self.emphasis_overlay)
        self.last_sort_indices = final_indices
        self.fig.canvas.draw_idle()

    def update_phase_data(self, phases, rhythm_scores, rhythm_mask=None, sort_desc=True, 
                          period=None, minutes_per_frame=None, reference_phase=None, trend_window_hours=None):
        self.phases = phases
        self.rhythm_scores = rhythm_scores
        self.rhythm_mask = rhythm_mask
        self.rhythm_sort_desc = sort_desc
        
        if period is not None: self.period = period
        if minutes_per_frame is not None: self.minutes_per_frame = minutes_per_frame
        self.reference_phase = reference_phase 
        if trend_window_hours is not None: self.trend_window_hours = trend_window_hours

        self.sort_values = {"Y-coordinate": self.roi_data[:, 1]}
        if self.phases is not None: self.sort_values["Phase"] = self.phases
        if self.rhythm_scores is not None: self.sort_values["Rhythmicity"] = self.rhythm_scores
        
        current_sort = self.radio_buttons.value_selected
        if current_sort in self.sort_values: self.on_sort_change(current_sort)

        if self.current_selected_index is not None:
            self.update_selected_trace(self.current_selected_index)

    def update_rhythm_emphasis(self, rhythm_mask, is_emphasized):
        self.is_emphasized, self.rhythm_mask = is_emphasized, rhythm_mask
        self.on_sort_change(self.radio_buttons.value_selected)

    def update_selected_trace(self, original_index):
        self.current_selected_index = original_index

        while len(self.ax_trace.lines) > 2:
            self.ax_trace.lines[-1].remove()
            
        if self.filtered_indices is not None:
            try: current_index = np.where(self.filtered_indices == original_index)[0][0]
            except IndexError:
                self.trace_line.set_data([], [])
                self.fit_line.set_data([], [])
                self.ax_trace.set_title("Selected Cell Trace (Not in current filter)")
                self.fig.canvas.draw_idle()
                return
        else: current_index = original_index

        if 0 <= current_index < self.traces_data.shape[1] - 1:
            time_frames = self.traces_data[:, 0]
            raw_intensity = self.traces_data[:, current_index + 1]
            
            mpf = self.minutes_per_frame or 15.0
            trend_win = self.trend_window_hours or 36.0
            win_frames = compute_median_window_frames(mpf, trend_win, len(raw_intensity))
            detrended = preprocess_for_rhythmicity(raw_intensity, method="running_median", median_window_frames=win_frames)
            
            self.trace_line.set_data(time_frames, detrended)
            
            title_text = f"Trace for ROI {original_index + 1}"
            
            if self.period and self.minutes_per_frame:
                time_hours = time_frames * (self.minutes_per_frame / 60.0)
                res = csn.cosinor_analysis(detrended, time_hours, self.period)
                
                if not np.isnan(res['amplitude']):
                    w = 2 * np.pi / self.period
                    model = res['mesor'] + res['amplitude'] * np.cos(w * (time_hours - res['acrophase']))
                    self.fit_line.set_data(time_frames, model)
                    
                    cell_phase_hours = res['acrophase']
                    period_frames = self.period / (self.minutes_per_frame / 60.0)
                    cell_peak_frame_base = (cell_phase_hours / (self.minutes_per_frame / 60.0))
                    
                    ref_text = ""
                    final_peak_frame = cell_peak_frame_base
                    
                    if self.reference_phase is not None:
                        ref_phase_frame = (self.reference_phase / (self.minutes_per_frame / 60.0))
                        self.ax_trace.axvline(ref_phase_frame, color='k', linestyle='--', alpha=0.8, label='Ref Peak')
                        
                        delta = ref_phase_frame - cell_peak_frame_base
                        cycles_shift = round(delta / period_frames)
                        candidate_frame = cell_peak_frame_base + (cycles_shift * period_frames)
                        
                        max_frame = time_frames[-1]
                        if 0 <= candidate_frame <= max_frame:
                            final_peak_frame = candidate_frame
                        else:
                            if 0 <= cell_peak_frame_base <= max_frame:
                                final_peak_frame = cell_peak_frame_base
                            else:
                                if cell_peak_frame_base < 0:
                                    final_peak_frame = cell_peak_frame_base + period_frames
                        
                        diff = (cell_phase_hours - self.reference_phase + self.period/2) % self.period - self.period/2
                        sign = "+" if diff > 0 else ""
                        ref_text = f" | Ref: {self.reference_phase:.1f}h | : {sign}{diff:.1f}h"
                    
                    self.ax_trace.axvline(final_peak_frame, color='r', linestyle='-', alpha=0.8, label='Cell Peak')
                    title_text += f" | Phase: {cell_phase_hours:.1f}h{ref_text}"
                else:
                     self.fit_line.set_data([], [])
            else:
                self.fit_line.set_data([], [])

            self.ax_trace.set_title(title_text, fontsize=10)
            self.ax_trace.relim()
            self.ax_trace.autoscale_view()
        else:
            self.trace_line.set_data([], [])
            self.fit_line.set_data([], [])
            self.ax_trace.set_title("Selected Cell Trace")
            
        self.fig.canvas.draw_idle()

    def get_export_data(self):
        if self.normalized_data.size == 0: return None, ""
        sorted_data = self.normalized_data[:, self.last_sort_indices].T
        if self.filtered_indices is not None:
            sorted_original_indices = self.filtered_indices[self.last_sort_indices]
        else:
            sorted_original_indices = self.last_sort_indices
        df = pd.DataFrame(sorted_data)
        df.columns = [f"Frame_{i}" for i in range(sorted_data.shape[1])]
        df.insert(0, "Cell_ID", sorted_original_indices + 1)
        return df, "heatmap_data.csv"

class ContrastViewer:
    def __init__(self, fig, ax, bg_image, com_points, on_change_callback, on_select_callback, filtered_indices=None, rois=None):
        self.fig = fig
        self.ax = ax
        self.com_points = com_points
        self.on_change_callback = on_change_callback
        self.on_select_callback = on_select_callback
        self.filtered_indices = filtered_indices
        self.rois = rois or []
        self.highlight_artist = None
        self.scatter_artists = []

        self.fig.subplots_adjust(left=0.1, bottom=0.25, right=0.85, top=0.9)

        self.image_artist = ax.imshow(bg_image, cmap="gray")
        ax.set_title("Center of Mass (Click to Select Trajectory)")

        ax_contrast = fig.add_axes([0.25, 0.10, 0.60, 0.03])
        ax_brightness = fig.add_axes([0.25, 0.05, 0.60, 0.03])
        
        min_val, max_val = float(bg_image.min()), float(bg_image.max())
        self.contrast_slider = Slider(ax=ax_contrast, label="Contrast", valmin=min_val, valmax=max_val, valinit=max_val)
        self.brightness_slider = Slider(ax=ax_brightness, label="Brightness", valmin=min_val, valmax=max_val, valinit=min_val)
        self.contrast_slider.on_changed(self.update)
        self.brightness_slider.on_changed(self.update)
        self.fig.canvas.mpl_connect('button_press_event', self.on_click)
        self.update(None)
        
        self._draw_rois()    
        self._draw_scatter() 

    def _draw_rois(self):
        if not self.rois:
            return

        style_map = {
            "Include": {"color": "lime", "linestyle": "-", "linewidth": 1.5},
            "Exclude": {"color": "red", "linestyle": "-", "linewidth": 1.5},
            "Phase Reference": {"color": "cyan", "linestyle": "--", "linewidth": 1.5},
            "Phase Axis": {"color": "magenta", "linestyle": "-", "linewidth": 2.0}
        }

        for roi in self.rois:
            mode = roi.get("mode", "Include")
            verts = roi.get("path_vertices", [])
            if not verts:
                continue
            
            style = style_map.get(mode, style_map["Include"])
            
            # Draw Line instead of Polygon for Axis
            if mode == "Phase Axis":
                xs, ys = zip(*verts)
                self.ax.plot(xs, ys, **style, label=mode)
            else:
                poly = Polygon(
                    verts, 
                    closed=True, 
                    fill=False, 
                    edgecolor=style["color"], 
                    linestyle=style["linestyle"], 
                    linewidth=style["linewidth"],
                    label=mode
                )
                self.ax.add_patch(poly)
        
        handles, labels = self.ax.get_legend_handles_labels()
        if handles:
            by_label = dict(zip(labels, handles))
            self.ax.legend(by_label.values(), by_label.keys(), loc='upper right', fontsize='small', framealpha=0.5)

    def _draw_scatter(self, rhythm_mask=None, is_emphasized=False):
        for artist in self.scatter_artists:
            artist.remove()
        self.scatter_artists.clear()

        if len(self.com_points) == 0:
            self.fig.canvas.draw_idle()
            return

        if is_emphasized and rhythm_mask is not None:
            rhythmic_pts = self.com_points[rhythm_mask]
            non_rhythmic_pts = self.com_points[~rhythm_mask]
            
            if len(rhythmic_pts) > 0:
                s1 = self.ax.plot(rhythmic_pts[:, 0], rhythmic_pts[:, 1], ".", color="red", markersize=5, alpha=0.8)[0]
                self.scatter_artists.append(s1)
            if len(non_rhythmic_pts) > 0:
                s2 = self.ax.plot(non_rhythmic_pts[:, 0], non_rhythmic_pts[:, 1], ".", color="gray", markersize=3, alpha=0.4)[0]
                self.scatter_artists.append(s2)
        else:
            s = self.ax.plot(self.com_points[:, 0], self.com_points[:, 1], ".", color="red", markersize=5, alpha=0.8)[0]
            self.scatter_artists.append(s)
        
        self.fig.canvas.draw_idle()

    def update_rhythm_emphasis(self, rhythm_mask, is_emphasized):
        self._draw_scatter(rhythm_mask, is_emphasized)

    def on_click(self, event):
        if event.inaxes != self.ax or len(self.com_points) == 0:
            return
        distances = np.sqrt((self.com_points[:, 0] - event.xdata)**2 + (self.com_points[:, 1] - event.ydata)**2)
        selected_index = np.argmin(distances) 

        if distances[selected_index] < 20:
            if self.filtered_indices is not None:
                original_index = self.filtered_indices[selected_index]
            else:
                original_index = selected_index
            
            self.highlight_point(original_index)

            if self.on_select_callback:
                self.on_select_callback(original_index)

    def highlight_point(self, index):
        if self.highlight_artist:
            self.highlight_artist.remove()
            self.highlight_artist = None
        
        local_index = None
        if index is not None:
            if self.filtered_indices is not None:
                matches = np.where(self.filtered_indices == index)[0]
                if len(matches) > 0:
                    local_index = matches[0]
                else:
                    local_index = None
            else:
                local_index = index

        if local_index is not None and 0 <= local_index < len(self.com_points):
            point = self.com_points[local_index]
            self.highlight_artist = self.ax.plot(point[0], point[1], 'o', markersize=12, markerfacecolor='none', markeredgecolor='cyan', markeredgewidth=2)[0]
        
        self.fig.canvas.draw_idle()

    def update(self, _):
        vmin = self.brightness_slider.val
        vmax = self.contrast_slider.val
        if vmax <= vmin: vmax = vmin + 1e-6
        self.image_artist.set_clim(vmin, vmax)
        self.fig.canvas.draw_idle()
        if self.on_change_callback:
            self.on_change_callback(vmin, vmax)

class TrajectoryInspector:
    def __init__(self, fig, ax, trajectories, movie_stack):
        self.fig = fig
        self.ax = ax
        self.trajectories = trajectories
        self.movie_stack = movie_stack
        self.num_frames = len(movie_stack)
        self.num_trajectories = len(trajectories)
        self.index = 0
        self.vmin = None
        self.vmax = None
        self.bg_artist = None

        self.fig.subplots_adjust(left=0.1, bottom=0.25, right=0.85, top=0.9)

        ax_prev = fig.add_axes([0.65, 0.05, 0.1, 0.04])
        ax_next = fig.add_axes([0.76, 0.05, 0.1, 0.04])
        from matplotlib.widgets import Button
        self.btn_prev = Button(ax_prev, "Previous")
        self.btn_next = Button(ax_next, "Next")
        self.btn_prev.on_clicked(self.prev_trajectory)
        self.btn_next.on_clicked(self.next_trajectory)

        ax_slider = fig.add_axes([0.15, 0.10, 0.45, 0.03])
        self.frame_slider = Slider(
            ax=ax_slider,
            label='Frame',
            valmin=0,
            valmax=self.num_frames - 1,
            valinit=0,
            valstep=1
        )
        self.frame_slider.on_changed(self.on_frame_change)
        
        self.update()

    def on_frame_change(self, frame_index):
        self.update()

    def set_trajectory(self, index):
        if 0 <= index < self.num_trajectories:
            self.index = index
            self.update()

    def update_contrast(self, vmin, vmax):
        self.vmin = vmin
        self.vmax = vmax
        if self.bg_artist:
            self.bg_artist.set_clim(vmin, vmax)
            self.fig.canvas.draw_idle()

    def next_trajectory(self, _):
        if self.num_trajectories > 0:
            self.index = (self.index + 1) % self.num_trajectories
            self.update()

    def prev_trajectory(self, _):
        if self.num_trajectories > 0:
            self.index = (self.index - 1 + self.num_trajectories) % self.num_trajectories
            self.update()

    def update(self):
        self.ax.clear()
        current_frame = int(self.frame_slider.val)

        self.bg_artist = self.ax.imshow(
            self.movie_stack[current_frame],
            cmap="gray",
            vmin=self.vmin,
            vmax=self.vmax,
        )
        
        if self.num_trajectories > 0:
            traj = self.trajectories[self.index]
            self.ax.plot(
                traj[:, 1], traj[:, 0], '-', color='cyan', linewidth=1, alpha=0.7
            )
            current_pos = traj[current_frame]
            self.ax.plot(
                current_pos[1], current_pos[0], 'o', 
                markersize=10, 
                markerfacecolor=(1, 1, 0, 0.5), 
                markeredgecolor='yellow',
                markeredgewidth=1.5
            )
            self.ax.set_title(
                f"Trajectory {self.index + 1} / {self.num_trajectories} (Frame {current_frame + 1}/{self.num_frames})"
            )
        else:
            self.ax.set_title("No Trajectories to Display")

        self.ax.set_xlim(0, self.movie_stack[0].shape[1])
        self.ax.set_ylim(self.movie_stack[0].shape[0], 0)
        self.fig.canvas.draw_idle()


class PhaseMapViewer:
    def __init__(self, fig, ax, bg_image, rhythmic_df, on_select_callback, vmin=None, vmax=None):
        self.fig = fig
        self.ax = ax
        self.rhythmic_df = rhythmic_df
        self.roi_data = self.rhythmic_df[['X_Position', 'Y_Position']].values if not self.rhythmic_df.empty else np.array([])
        self.period_hours = self.rhythmic_df['Period_Hours'].iloc[0] if not self.rhythmic_df.empty else 24
        self.on_select_callback = on_select_callback
        self.highlight_artist = None
        
        self.is_cyclic = True 
        self.cmap_cyclic = cet.cm.cyclic_mygbm_30_95_c78
        self.cmap_diverging = 'coolwarm'

        self.fig.subplots_adjust(left=0.1, bottom=0.25, right=0.85, top=0.9)

        self.bg_artist = ax.imshow(bg_image, cmap="gray", vmin=vmin, vmax=vmax)
        
        if not self.rhythmic_df.empty:
            self.scatter = ax.scatter(
                self.rhythmic_df['X_Position'], self.rhythmic_df['Y_Position'],
                c=self.rhythmic_df['Relative_Phase_Hours'],
                cmap=self.cmap_cyclic, s=25, edgecolor="black", linewidth=0.5,
            )
            cax = fig.add_axes([0.86, 0.25, 0.02, 0.6])
            self.cbar = fig.colorbar(self.scatter, cax=cax)
            self.cbar.set_label("Relative Peak Time (hours)", fontsize=10)
            
            ax_slider = fig.add_axes([0.25, 0.10, 0.60, 0.03])
            max_range = self.period_hours / 2.0
            self.range_slider = Slider(ax=ax_slider, label="Phase Range (+/- hrs)", valmin=1.0, valmax=max_range, valinit=max_range)
            self.range_slider.on_changed(self.update_clim)
            
            ax_button = fig.add_axes([0.25, 0.05, 0.15, 0.04])
            self.cmap_btn = Button(ax_button, "Mode: Cyclic")
            self.cmap_btn.on_clicked(self.toggle_cmap)
            
            self.update_clim(max_range)

        ax.set_title("Spatiotemporal Phase Map (Click to Select Trajectory)")
        ax.set_xticks([]); ax.set_yticks([])
        self.fig.canvas.mpl_connect('button_press_event', self.on_click)

    def toggle_cmap(self, event):
        self.is_cyclic = not self.is_cyclic
        new_cmap = self.cmap_cyclic if self.is_cyclic else self.cmap_diverging
        label = "Mode: Cyclic" if self.is_cyclic else "Mode: Diverging"
        self.scatter.set_cmap(new_cmap)
        self.cmap_btn.label.set_text(label)
        self.fig.canvas.draw_idle()

    def on_click(self, event):
        if event.inaxes != self.ax or self.rhythmic_df.empty: return
        distances = np.sqrt((self.roi_data[:, 0] - event.xdata)**2 + (self.roi_data[:, 1] - event.ydata)**2)
        selected_index = np.argmin(distances) 
        
        if distances[selected_index] < 20:
            global_index = int(self.rhythmic_df.iloc[selected_index]['Original_ROI_Index'] - 1)
            self.highlight_point(global_index)
            if self.on_select_callback: self.on_select_callback(selected_index)

    def highlight_point(self, original_index):
        if self.highlight_artist: self.highlight_artist.remove(); self.highlight_artist = None
        
        if original_index is not None and not self.rhythmic_df.empty:
            matches = self.rhythmic_df.index[self.rhythmic_df['Original_ROI_Index'] == (original_index + 1)].tolist()
            if matches:
                row_idx = matches[0]
                point = self.roi_data[row_idx]
                self.highlight_artist = self.ax.plot(point[0], point[1], 'o', markersize=15, markerfacecolor='none', markeredgecolor='white', markeredgewidth=2)[0]
                
        self.fig.canvas.draw_idle()

    def update_contrast(self, vmin, vmax):
        if self.bg_artist is not None: self.bg_artist.set_clim(vmin, vmax); self.fig.canvas.draw_idle()

    def update_clim(self, val):
        if hasattr(self, "scatter"): self.scatter.set_clim(-val, val); self.fig.canvas.draw_idle()

    def get_export_data(self):
        return self.rhythmic_df, "phase_map_data.csv"
        
class GroupScatterViewer:
    def __init__(self, fig, ax, group_df, grid_bins=None):
        self.fig = fig
        self.ax = ax
        self.full_group_df = group_df # Store all data
        self.grid_bins = grid_bins
        self.period_hours = self.full_group_df['Period_Hours'].iloc[0] if not self.full_group_df.empty else 24
        
        self.is_cyclic = True 
        self.cmap_cyclic = cet.cm.cyclic_mygbm_30_95_c78
        self.cmap_diverging = 'coolwarm'

        self.fig.subplots_adjust(left=0.1, bottom=0.25, right=0.85, top=0.9)
        ax.set_title("Group Phase Distribution")

        # Radio Buttons for Group Filter (Positioned Middle Bottom)
        ax_radio = fig.add_axes([0.4, 0.05, 0.2, 0.1])
        self.group_radio = RadioButtons(ax_radio, ['All', 'Control', 'Experiment'])
        self.group_radio.on_clicked(self.update_filter)

        # Scatter setup (initially empty)
        self.scatter = ax.scatter([], [], cmap=self.cmap_cyclic, s=25, edgecolor="black", linewidth=0.5, alpha=1.0, zorder=10)
        
        cax = fig.add_axes([0.86, 0.25, 0.02, 0.6])
        self.cbar = fig.colorbar(self.scatter, cax=cax)
        self.cbar.set_label("Relative Peak Time (Circadian Hours, CT)")
        
        ax_slider = fig.add_axes([0.25, 0.15, 0.60, 0.03])
        max_range = self.period_hours / 2.0
        self.range_slider = Slider(ax=ax_slider, label="Phase Range", valmin=1.0, valmax=max_range, valinit=max_range)
        self.range_slider.on_changed(self.update_clim)
        
        ax_button = fig.add_axes([0.10, 0.05, 0.15, 0.04])
        self.cmap_btn = Button(ax_button, "Mode: Cyclic")
        self.cmap_btn.on_clicked(self.toggle_cmap)

        # Draw Grid
        if not self.full_group_df.empty:
            if grid_bins is not None:
                xbins, ybins = grid_bins
                grid_style = {'color': '#999999', 'linestyle': ':', 'linewidth': 0.5, 'alpha': 0.4, 'zorder': 0}
                for x in xbins: ax.axvline(x, **grid_style)
                for y in ybins: ax.axhline(y, **grid_style)
            
            # Set Limits based on FULL data
            xs, ys = self.full_group_df['Warped_X'], self.full_group_df['Warped_Y']
            cx, cy = (xs.min() + xs.max()) / 2, (ys.min() + ys.max()) / 2
            max_range = max(xs.max() - xs.min(), ys.max() - ys.min())
            half = (max_range * 1.15) / 2 
            ax.set_xlim(cx - half, cx + half)
            ax.set_ylim(cy - half, cy + half)

        ax.set_aspect("equal", adjustable="box")
        ax.invert_yaxis()
        ax.set_xticks([]); ax.set_yticks([])

        self.annot = ax.annotate("", xy=(0,0), xytext=(20,20),textcoords="offset points",
                                 bbox=dict(boxstyle="round", fc="w", alpha=0.9), arrowprops=dict(arrowstyle="->"))
        self.annot.set_visible(False)
        self.fig.canvas.mpl_connect("motion_notify_event", self.hover)

        # Initial Plot
        self.update_filter('All')

    def update_filter(self, label):
        if self.full_group_df.empty: return
        
        if label == 'All':
            self.current_df = self.full_group_df
        else:
            self.current_df = self.full_group_df[self.full_group_df['Group'] == label]
            
        # Update Scatter Data
        # Note: set_offsets takes (N, 2), set_array takes (N,)
        self.scatter.set_offsets(self.current_df[['Warped_X', 'Warped_Y']].values)
        self.scatter.set_array(self.current_df['Relative_Phase_Hours'].values)
        
        # Reset clim to force refresh
        val = self.range_slider.val
        self.scatter.set_clim(-val, val)
        
        self.fig.canvas.draw_idle()

    def toggle_cmap(self, event):
        self.is_cyclic = not self.is_cyclic
        new_cmap = self.cmap_cyclic if self.is_cyclic else self.cmap_diverging
        label = "Mode: Cyclic" if self.is_cyclic else "Mode: Diverging"
        self.scatter.set_cmap(new_cmap)
        self.cmap_btn.label.set_text(label)
        self.fig.canvas.draw_idle()

    def update_clim(self, val):
        self.scatter.set_clim(-val, val)
        self.fig.canvas.draw_idle()

    def update_annot(self, ind):
        if len(ind["ind"]) == 0: return
        idx = ind["ind"][0]
        # Map back to dataframe row (reset_index logic might be needed if df is filtered? 
        # No, current_df matches the scatter points 1:1 in order)
        row = self.current_df.iloc[idx]
        pos = self.scatter.get_offsets()[idx]
        self.annot.xy = pos
        text = f"Animal: {row['Source_Animal']}\nPhase: {row['Relative_Phase_Hours']:.2f} h\nX: {row['Warped_X']:.1f}, Y: {row['Warped_Y']:.1f}"
        self.annot.set_text(text)

    def hover(self, event):
        vis = self.annot.get_visible()
        if event.inaxes == self.ax:
            cont, ind = self.scatter.contains(event)
            if cont:
                self.update_annot(ind)
                self.annot.set_visible(True)
                self.fig.canvas.draw_idle()
            else:
                if vis: self.annot.set_visible(False); self.fig.canvas.draw_idle()

    def get_export_data(self):
        return self.current_df, "group_scatter_data.csv"

class GroupAverageMapViewer:
    def __init__(self, fig, ax, group_binned_df, group_scatter_df, grid_dims, do_smooth):
        self.fig = fig
        self.ax = ax
        self.full_binned = group_binned_df # Unused in dynamic, but kept for ref
        self.full_scatter = group_scatter_df
        self.grid_dims = grid_dims
        self.do_smooth = do_smooth
        self.period_hours = self.full_scatter['Period_Hours'].iloc[0] if not self.full_scatter.empty else 24
        
        self.is_cyclic = True 
        self.cmap_cyclic = cet.cm.cyclic_mygbm_30_95_c78
        self.cmap_diverging = 'coolwarm'

        self.fig.subplots_adjust(left=0.1, bottom=0.25, right=0.85, top=0.9)
        ax.set_title("Group Average Phase Map")

        # Radio Buttons
        ax_radio = fig.add_axes([0.4, 0.05, 0.2, 0.1])
        self.group_radio = RadioButtons(ax_radio, ['All', 'Control', 'Experiment'])
        self.group_radio.on_clicked(self.update_filter)

        # Initial placeholder image
        self.im = ax.imshow(np.zeros((grid_dims[1], grid_dims[0])), origin="lower", cmap=self.cmap_cyclic)

        # Controls
        cax = fig.add_axes([0.86, 0.25, 0.02, 0.6])
        self.cbar = fig.colorbar(self.im, cax=cax)
        self.cbar.set_label("Relative Peak Time (Circadian Hours, CT)")
        
        ax_slider = fig.add_axes([0.25, 0.15, 0.60, 0.03])
        max_range = self.period_hours / 2.0
        self.range_slider = Slider(ax=ax_slider, label="Phase Range", valmin=1.0, valmax=max_range, valinit=max_range)
        self.range_slider.on_changed(self.update_clim)
        
        ax_button = fig.add_axes([0.10, 0.05, 0.15, 0.04])
        self.cmap_btn = Button(ax_button, "Mode: Cyclic")
        self.cmap_btn.on_clicked(self.toggle_cmap)

        if not self.full_scatter.empty:
            # Fixed Limits based on FULL data to ensure alignment doesn't jump
            xs, ys = self.full_scatter['Warped_X'], self.full_scatter['Warped_Y']
            self.extent = [xs.min(), xs.max(), ys.min(), ys.max()]
            cx, cy = (xs.min() + xs.max()) / 2, (ys.min() + ys.max()) / 2
            max_range = max(xs.max() - xs.min(), ys.max() - ys.min())
            half = (max_range * 1.15) / 2
            ax.set_xlim(cx - half, cx + half)
            ax.set_ylim(cy - half, cy + half)
            self.im.set_extent(self.extent)
            
            # Calc initial view
            self.update_filter('All')
        
        ax.set_aspect("equal", adjustable="box")
        ax.invert_yaxis()
        ax.set_xticks([]); ax.set_yticks([])

        self.annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                                 bbox=dict(boxstyle="round", fc="w", alpha=0.9), arrowprops=dict(arrowstyle="->"))
        self.annot.set_visible(False)
        self.fig.canvas.mpl_connect("motion_notify_event", self.hover)

    def update_filter(self, label):
        if self.full_scatter.empty: return
        
        if label == 'All':
            df = self.full_scatter
        else:
            df = self.full_scatter[self.full_scatter['Group'] == label]
            
        # Recalculate Binned Grid for this subset
        nx, ny = self.grid_dims
        binned_grid = np.full((ny, nx), np.nan)
        self.count_grid = np.zeros((ny, nx), dtype=int)
        
        if df.empty:
            self.im.set_data(binned_grid)
            self.fig.canvas.draw_idle()
            return

        # Recalculate Means
        def circmean_phase(series):
            rad = (series / (self.period_hours/2.0)) * np.pi 
            mean_rad = circmean(rad, low=-np.pi, high=np.pi)
            return (mean_rad / np.pi) * (self.period_hours/2.0)

        grouped = df.groupby(['Grid_X_Index', 'Grid_Y_Index'])['Relative_Phase_Hours'].apply(circmean_phase).reset_index()
        
        for _, row in grouped.iterrows():
            ix, iy = int(row['Grid_X_Index']), int(row['Grid_Y_Index'])
            if 0 <= iy < ny and 0 <= ix < nx:
                binned_grid[iy, ix] = row['Relative_Phase_Hours']
                
        # Metadata (Counts)
        counts = df.groupby(['Grid_X_Index', 'Grid_Y_Index']).size().reset_index(name='count')
        for _, row in counts.iterrows():
            ix, iy = int(row['Grid_X_Index']), int(row['Grid_Y_Index'])
            if 0 <= iy < ny and 0 <= ix < nx:
                self.count_grid[iy, ix] = row['count']

        # Smoothing
        if self.do_smooth:
             # [Same smoothing logic as before]
            original_grid = binned_grid.copy()
            rows, cols = original_grid.shape
            for r in range(rows):
                for c in range(cols):
                    if np.isnan(original_grid[r, c]):
                        r_min, r_max = max(0, r-1), min(rows, r+2)
                        c_min, c_max = max(0, c-1), min(cols, c+2)
                        window = original_grid[r_min:r_max, c_min:c_max]
                        valid = window[~np.isnan(window)]
                        if valid.size > 0:
                            rads = (valid / (self.period_hours / 2.0)) * np.pi
                            mean_rad = circmean(rads, low=-np.pi, high=np.pi)
                            binned_grid[r, c] = (mean_rad / np.pi) * (self.period_hours / 2.0)

        self.im.set_data(binned_grid)
        
        # Reset clim
        val = self.range_slider.val
        self.im.set_clim(-val, val)
        self.fig.canvas.draw_idle()

    def toggle_cmap(self, event):
        self.is_cyclic = not self.is_cyclic
        new_cmap = self.cmap_cyclic if self.is_cyclic else self.cmap_diverging
        label = "Mode: Cyclic" if self.is_cyclic else "Mode: Diverging"
        self.im.set_cmap(new_cmap)
        self.cmap_btn.label.set_text(label)
        self.fig.canvas.draw_idle()

    def update_clim(self, val):
        self.im.set_clim(-val, val)
        self.fig.canvas.draw_idle()
        
    def hover(self, event):
        if event.inaxes != self.ax:
            if self.annot.get_visible(): self.annot.set_visible(False); self.fig.canvas.draw_idle()
            return
        
        # [Existing hover logic uses self.im extent]
        extent = self.im.get_extent() 
        arr = self.im.get_array()
        ny, nx = arr.shape
        xmin, xmax, ymin, ymax = extent
        dx = (xmax - xmin) / nx
        dy = (ymax - ymin) / ny
        c = int((event.xdata - xmin) / dx)
        r = int((event.ydata - ymin) / dy)
        
        if 0 <= r < ny and 0 <= c < nx:
            val = arr[r, c]
            if np.ma.is_masked(val) or np.isnan(val):
                self.annot.set_visible(False); self.fig.canvas.draw_idle(); return
            
            count = self.count_grid[r, c]
            text = f"Phase: {val:.2f} h\nN={count} cells"
            if count == 0: text += "\n(Interpolated)"
            
            self.annot.xy = (event.xdata, event.ydata)
            self.annot.set_text(text)
            self.annot.set_visible(True)
            self.fig.canvas.draw_idle()
        else:
            if self.annot.get_visible(): self.annot.set_visible(False); self.fig.canvas.draw_idle()

    def get_export_data(self):
        # Return currently filtered data
        # We don't store the filtered binned df, so let's just return full scatter
        return self.full_scatter, "group_data.csv"

class InterpolatedMapViewer:
    def __init__(self, fig, ax, roi_data, relative_phases,
                 period_hours, grid_resolution, rois=None):
        self.fig = fig
        self.ax = ax
        self.period_hours = period_hours
        
        self.is_cyclic = True 
        self.cmap_cyclic = cet.cm.cyclic_mygbm_30_95_c78
        self.cmap_diverging = 'coolwarm'

        self.fig.subplots_adjust(left=0.1, bottom=0.25, right=0.85, top=0.9)

        ax.set_title("Interpolated Spatiotemporal Phase Map")

        if len(roi_data) < 4:
            ax.text(0.5, 0.5, "Not enough data points (<4) for interpolation.", ha="center", va="center")
            return

        phase_angles_rad = (relative_phases / (period_hours / 2.0)) * pi
        x_comp = np.cos(phase_angles_rad)
        y_comp = np.sin(phase_angles_rad)

        xs = roi_data[:, 0]
        ys = roi_data[:, 1]
        bounds_x_min, bounds_x_max = xs.min(), xs.max()
        bounds_y_min, bounds_y_max = ys.min(), ys.max()
        
        if rois:
            include_verts = []
            for r in rois:
                if isinstance(r.get("mode"), str) and r.get("mode").strip().lower() == "include" and "path_vertices" in r:
                    include_verts.append(np.array(r["path_vertices"]))
            
            if include_verts:
                all_verts = np.vstack(include_verts)
                roi_x_min, roi_x_max = all_verts[:, 0].min(), all_verts[:, 0].max()
                roi_y_min, roi_y_max = all_verts[:, 1].min(), all_verts[:, 1].max()
                bounds_x_min = min(bounds_x_min, roi_x_min)
                bounds_x_max = max(bounds_x_max, roi_x_max)
                bounds_y_min = min(bounds_y_min, roi_y_min)
                bounds_y_max = max(bounds_y_max, roi_y_max)

        x_buf = (bounds_x_max - bounds_x_min) * 0.05
        y_buf = (bounds_y_max - bounds_y_min) * 0.05
        grid_x_min, grid_x_max = bounds_x_min - x_buf, bounds_x_max + x_buf
        grid_y_min, grid_y_max = bounds_y_min - y_buf, bounds_y_max + y_buf

        grid_x, grid_y = np.mgrid[
            grid_x_min:grid_x_max:complex(grid_resolution),
            grid_y_min:grid_y_max:complex(grid_resolution),
        ]
        grid_points = np.vstack([grid_x.ravel(), grid_y.ravel()]).T

        rbf_x = RBFInterpolator(roi_data, x_comp, kernel="linear", smoothing=1.0)
        rbf_y = RBFInterpolator(roi_data, y_comp, kernel="linear", smoothing=1.0)
        
        gx = rbf_x(grid_points)
        gy = rbf_y(grid_points)
        angles = arctan2(gy, gx)
        grid_z = (angles / pi) * (period_hours / 2.0)
        grid_z = grid_z.reshape(grid_x.shape)

        if rois:
            final_mask = np.zeros(grid_x.shape, dtype=bool)

            def _mode_lower(r):
                m = r.get("mode", "")
                return m.strip().lower() if isinstance(m, str) else ""

            def _as_path(r):
                # Prefer prebuilt Path, otherwise build from vertices
                p = r.get("path", None)
                if isinstance(p, Path):
                    return p
                verts = r.get("path_vertices", None)
                if verts is None:
                    return None
                try:
                    return Path(verts)
                except Exception:
                    return None

            include_paths = []
            exclude_paths = []

            for r in rois:
                mode = _mode_lower(r)
                p = _as_path(r)
                if p is None:
                    continue
                if mode == "include":
                    include_paths.append(p)
                elif mode == "exclude":
                    exclude_paths.append(p)

            if include_paths:
                for p in include_paths:
                    final_mask |= p.contains_points(grid_points).reshape(grid_x.shape)
            else:
                # Fallback: convex hull of the rhythmic ROI points
                if len(roi_data) > 2:
                    hull = ConvexHull(roi_data)
                    hpath = Path(roi_data[hull.vertices])
                    final_mask = hpath.contains_points(grid_points).reshape(grid_x.shape)

            for p in exclude_paths:
                final_mask &= ~p.contains_points(grid_points).reshape(grid_x.shape)

            grid_z[~final_mask] = np.nan

        else:
            # No ROIs provided, fall back to convex hull of data points
            if len(roi_data) > 2:
                hull = ConvexHull(roi_data)
                hpath = Path(roi_data[hull.vertices])
                mask = hpath.contains_points(grid_points).reshape(grid_x.shape)
                grid_z[~mask] = np.nan

        self.im = ax.imshow(
            grid_z.T,
            origin="upper",
            extent=[grid_x_min, grid_x_max, grid_y_max, grid_y_min], 
            cmap=self.cmap_cyclic,
            interpolation="bilinear",
        )

        cx = (bounds_x_min + bounds_x_max) / 2
        cy = (bounds_y_min + bounds_y_max) / 2
        range_x = bounds_x_max - bounds_x_min
        range_y = bounds_y_max - bounds_y_min
        max_range = max(range_x, range_y)
        half_span = (max_range * 1.15) / 2 
        
        ax.set_xlim(cx - half_span, cx + half_span)
        ax.set_ylim(cy + half_span, cy - half_span) 

        ax.set_aspect("equal", adjustable="box")
        ax.set_xticks([])
        ax.set_yticks([])

        cax = fig.add_axes([0.86, 0.25, 0.02, 0.6])
        self.cbar = fig.colorbar(self.im, cax=cax)
        self.cbar.set_label("Relative Peak Time (hours)", fontsize=10)

        ax_slider = fig.add_axes([0.25, 0.10, 0.60, 0.03])
        max_range = self.period_hours / 2.0
        self.range_slider = Slider(
            ax=ax_slider,
            label='Phase Range (+/- hrs)',
            valmin=1.0,
            valmax=max_range,
            valinit=max_range,
        )
        self.range_slider.on_changed(self.update_clim)
        
        ax_button = fig.add_axes([0.25, 0.05, 0.15, 0.04])
        self.cmap_btn = Button(ax_button, "Mode: Cyclic")
        self.cmap_btn.on_clicked(self.toggle_cmap)
        
        self.update_clim(max_range)

    def toggle_cmap(self, event):
        self.is_cyclic = not self.is_cyclic
        new_cmap = self.cmap_cyclic if self.is_cyclic else self.cmap_diverging
        label = "Mode: Cyclic" if self.is_cyclic else "Mode: Diverging"
        self.im.set_cmap(new_cmap)
        self.cmap_btn.label.set_text(label)
        self.fig.canvas.draw_idle()

    def update_clim(self, val):
        for im in self.ax.images:
            im.set_clim(-val, val)
        self.fig.canvas.draw_idle()

class PhaseGradientViewer:
    def __init__(self, fig, ax, gradient_data):
        self.fig = fig
        self.ax = ax
        self.gradient_data = gradient_data
        
        self.fig.subplots_adjust(left=0.15, bottom=0.20, right=0.95, top=0.9)
        ax.set_title("Dorsoventral Phase Gradient")
        ax.set_xlabel("Anatomical Position (s)\n(0.0 = Dorsal/Start, 1.0 = Ventral/End)")
        ax.set_ylabel("Relative Phase (CT Hours)")
        ax.grid(True, linestyle=':', alpha=0.6)
        
        if not gradient_data:
            ax.text(0.5, 0.5, "No gradient data available.", ha='center')
            self.fig.canvas.draw_idle()
            return

        # Group data
        groups = {'Control': [], 'Experiment': []}
        for entry in gradient_data:
            g = entry.get('group', 'Unassigned')
            if g in groups: groups[g].append(entry)
            else:
                if 'Unassigned' not in groups: groups['Unassigned'] = []
                groups['Unassigned'].append(entry)

        colors = {'Control': 'blue', 'Experiment': 'red', 'Unassigned': 'gray'}
        stats_text = "Group Metrics (Mean  SEM):\n"
        
        for grp, entries in groups.items():
            if not entries: continue
            
            color = colors.get(grp, 'gray')
            all_phases = []
            slopes = []
            
            # Plot Individual Lines
            for entry in entries:
                s = entry['s']
                p = entry['phases']
                ax.plot(s, p, color=color, alpha=0.15, linewidth=1)
                all_phases.append(p)
                
                # Slope per animal
                mask = ~np.isnan(p)
                if np.sum(mask) > 2:
                    slope, _, _, _, _ = linregress(s[mask], p[mask])
                    slopes.append(slope)
            
            # Mean Profile
            all_phases = np.array(all_phases)
            mean_profile = []
            s_axis = entries[0]['s']
            
            for col in range(all_phases.shape[1]):
                col_data = all_phases[:, col]
                valid = col_data[~np.isnan(col_data)]
                if valid.size > 0:
                    rads = (valid / 24.0) * 2 * np.pi
                    m_rad = circmean(rads, low=-np.pi, high=np.pi)
                    mean_profile.append((m_rad / (2*np.pi)) * 24.0)
                else:
                    mean_profile.append(np.nan)
            
            ax.plot(s_axis, mean_profile, color=color, linewidth=3, label=f"{grp} Mean")
            
            # Stats text
            if slopes:
                m_slope = np.mean(slopes)
                s_slope = sem(slopes)
                stats_text += f"{grp} Slope: {m_slope:.2f}  {s_slope:.2f}\n"

        ax.legend(loc='upper left')
        
        props = dict(boxstyle='round', facecolor='white', alpha=0.8)
        ax.text(0.95, 0.05, stats_text, transform=ax.transAxes, fontsize=10,
                verticalalignment='bottom', horizontalalignment='right', bbox=props)
        
        ax_slider = fig.add_axes([0.25, 0.05, 0.50, 0.03])
        self.range_slider = Slider(ax=ax_slider, label="Phase Range (+/- h)", valmin=1.0, valmax=12.0, valinit=8.0)
        self.range_slider.on_changed(self.update_ylim)
        
        self.update_ylim(8.0) 

    def get_export_data(self):
        rows = []
        for entry in self.gradient_data:
            animal = entry['animal']
            group = entry.get('group', 'Unassigned') # Ensure group is captured
            s_vals = entry['s']
            p_vals = entry['phases']
            
            for i in range(len(s_vals)):
                val = p_vals[i]
                rows.append({
                    'Animal_ID': animal,
                    'Group': group, # Add Group column
                    'Anatomical_Pos_s': s_vals[i],
                    'Relative_Phase_CT': val,
                    'Bin_Index': i
                })
        df = pd.DataFrame(rows)
        return df, "phase_gradient_data.csv"

    def update_ylim(self, val):
        self.ax.set_ylim(-val, val)
        self.fig.canvas.draw_idle()

# --- ADD THIS CLASS TO THE END OF THE FILE ---

class RegionResultViewer(QtWidgets.QWidget):
    """
    Visualizes the results of the Region-Based Analysis.
    Tab 1: Atlas Map colored by Phase Difference.
    Tab 2: Statistical Table.
    """
    def __init__(self, zone_stats, atlas_polys_by_zone, parent=None):
        super().__init__(parent)
        self.zone_stats = zone_stats
        self.atlas_polys = atlas_polys_by_zone
        
        layout = QtWidgets.QVBoxLayout(self)
        
        self.tabs = QtWidgets.QTabWidget()
        layout.addWidget(self.tabs)
        
        # 1. Map Tab
        self.map_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.map_tab, "Region Map")
        map_layout = QtWidgets.QVBoxLayout(self.map_tab)
        
        self.fig = Figure(figsize=(8, 6))
        self.canvas = FigureCanvas(self.fig)
        self.toolbar = NavigationToolbar(self.canvas, self.map_tab)
        map_layout.addWidget(self.toolbar)
        map_layout.addWidget(self.canvas)
        
        # 2. Table Tab
        self.table_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.table_tab, "Stats Table")
        table_layout = QtWidgets.QVBoxLayout(self.table_tab)
        self.stats_table = QtWidgets.QTableWidget()
        table_layout.addWidget(self.stats_table)
        
        # 3. Animal Details Tab
        self.detail_tab = QtWidgets.QWidget()
        self.tabs.addTab(self.detail_tab, "Animal Details")
        detail_layout = QtWidgets.QVBoxLayout(self.detail_tab)
        
        self.detail_table = QtWidgets.QTableWidget()
        detail_layout.addWidget(self.detail_table)
        
        # Buttons for Details Tab
        btn_layout = QtWidgets.QHBoxLayout()
        self.btn_export_all = QtWidgets.QPushButton("Export Full Cell Data")
        self.btn_export_all.clicked.connect(self.export_full_cell_data)
        btn_layout.addWidget(self.btn_export_all)
        detail_layout.addLayout(btn_layout)
        
        self._draw_map()
        self._populate_table()
        self._populate_detail_table()

    def _draw_map(self):
        ax = self.fig.add_subplot(111)
        ax.set_title("Region Phase Differences (Exp - Ctrl)\n* = Significant (p < 0.05)")
        ax.set_aspect('equal')
        
        # Colormap setup: Blue (Early) -> White -> Red (Late)
        import matplotlib.cm as cm
        import matplotlib.colors as mcolors
        from matplotlib.patches import Polygon as MplPolygon
        
        norm = mcolors.Normalize(vmin=-4, vmax=4)
        mapper = cm.ScalarMappable(norm=norm, cmap='coolwarm')
        
        all_x, all_y = [], []

        for stat in self.zone_stats:
            zid = stat['id']
            diff = stat.get('diff_mean', 0)
            is_sig = stat.get('p_value', 1.0) < 0.05
            
            color = mapper.to_rgba(diff)
            
            polys = self.atlas_polys.get(zid, [])
            for poly_path in polys:
                verts = poly_path.vertices # Path object vertices
                all_x.extend(verts[:, 0])
                all_y.extend(verts[:, 1])
                
                poly = MplPolygon(verts, closed=True, facecolor=color, edgecolor='black', linewidth=1, alpha=0.8)
                ax.add_patch(poly)
                
                # Significance Marker
                cx, cy = np.mean(verts[:, 0]), np.mean(verts[:, 1])
                if is_sig:
                    ax.text(cx, cy, "*", fontsize=24, ha='center', va='center', color='black', weight='bold')
                
                # Label
                ax.text(cx, cy, f"\n{diff:+.1f}h", fontsize=9, ha='center', va='top', color='black', weight='bold')

        if all_x:
            pad = 50
            ax.set_xlim(min(all_x)-pad, max(all_x)+pad)
            ax.set_ylim(max(all_y)+pad, min(all_y)-pad) # Invert Y for imaging convention
        
        # Colorbar
        cbar = self.fig.colorbar(mapper, ax=ax, orientation='vertical', fraction=0.046, pad=0.04)
        cbar.set_label("Phase Difference (Hours)")
        cbar.set_ticks([-4, 0, 4])
        cbar.set_ticklabels(["-4h (Earlier)", "0h", "+4h (Later)"])
        
        self.canvas.draw()

    def _populate_table(self):
        cols = ["Zone ID", "Name", "N(Ctrl)", "N(Exp)", "Mean(Ctrl)", "Mean(Exp)", "Diff", "p-value"]
        self.stats_table.setColumnCount(len(cols))
        self.stats_table.setHorizontalHeaderLabels(cols)
        self.stats_table.setRowCount(len(self.zone_stats))
        
        for r, stat in enumerate(self.zone_stats):
            self.stats_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(stat['id'])))
            self.stats_table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(stat['name'])))
            self.stats_table.setItem(r, 2, QtWidgets.QTableWidgetItem(str(stat.get('n_ctrl', 0))))
            self.stats_table.setItem(r, 3, QtWidgets.QTableWidgetItem(str(stat.get('n_exp', 0))))
            self.stats_table.setItem(r, 4, QtWidgets.QTableWidgetItem(f"{stat.get('mean_ctrl', np.nan):.2f}"))
            self.stats_table.setItem(r, 5, QtWidgets.QTableWidgetItem(f"{stat.get('mean_exp', np.nan):.2f}"))
            
            diff_item = QtWidgets.QTableWidgetItem(f"{stat.get('diff_mean', np.nan):+.2f}")
            if stat.get('diff_mean', 0) > 0: diff_item.setForeground(QtGui.QColor('red'))
            else: diff_item.setForeground(QtGui.QColor('blue'))
            self.stats_table.setItem(r, 6, diff_item)
            
            p = stat.get('p_value', np.nan)
            p_str = "< 0.001" if p < 0.001 else f"{p:.4f}"
            p_item = QtWidgets.QTableWidgetItem(p_str)
            if p < 0.05:
                p_item.setFont(QtGui.QFont("Segoe UI", 9, QtGui.QFont.Bold))
                p_item.setBackground(QtGui.QColor("#d4edda")) # Light green
            self.stats_table.setItem(r, 7, p_item)
            
        self.stats_table.resizeColumnsToContents()

    def _populate_detail_table(self):
        """Populates the detail tab with per-animal data."""
        cols = ["Zone ID", "Zone Name", "Group", "Animal", "Mean Phase (h)", "N Cells"]
        self.detail_table.setColumnCount(len(cols))
        self.detail_table.setHorizontalHeaderLabels(cols)
        
        # Calculate total rows
        total_rows = sum(len(s['data']) for s in self.zone_stats)
        self.detail_table.setRowCount(total_rows)
        
        row_idx = 0
        for s in self.zone_stats:
            z_id = str(s['id'])
            z_name = str(s['name'])
            
            # Sort by group then animal for readability
            sorted_data = sorted(s['data'], key=lambda x: (x['group'], x['animal']))
            
            for d in sorted_data:
                self.detail_table.setItem(row_idx, 0, QtWidgets.QTableWidgetItem(z_id))
                self.detail_table.setItem(row_idx, 1, QtWidgets.QTableWidgetItem(z_name))
                self.detail_table.setItem(row_idx, 2, QtWidgets.QTableWidgetItem(str(d['group'])))
                self.detail_table.setItem(row_idx, 3, QtWidgets.QTableWidgetItem(str(d['animal'])))
                self.detail_table.setItem(row_idx, 4, QtWidgets.QTableWidgetItem(f"{d['mean']:.2f}"))
                self.detail_table.setItem(row_idx, 5, QtWidgets.QTableWidgetItem(str(d['n_cells'])))
                row_idx += 1
                
        self.detail_table.resizeColumnsToContents()

    def get_export_data(self):
        # Flatten stats to DF
        data = []
        for s in self.zone_stats:
            row = s.copy()
            if 'data' in row: del row['data'] 
            data.append(row)
        return pd.DataFrame(data), "region_stats.csv"

    def export_full_cell_data(self):
        """
        Exports the massive raw cell dump.
        """
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Export Full Cell Data", "region_raw_cells.csv", "CSV (*.csv)")
        if not path:
            return
            
        try:
            # Build huge list
            all_rows = []
            for s in self.zone_stats:
                z_id = s['id']
                z_name = s['name']
                for d in s['data']:
                    # d['raw_phases'] is a list or array
                    for ph in d.get('raw_phases', []):
                        all_rows.append({
                            'Zone_ID': z_id,
                            'Zone_Name': z_name,
                            'Group': d['group'],
                            'Animal': d['animal'],
                            'Cell_Phase_CT': ph
                        })
            
            df = pd.DataFrame(all_rows)
            df.to_csv(path, index=False)
            QtWidgets.QMessageBox.information(self, "Success", f"Exported {len(df)} cell records to:\n{path}")
            
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Export Error", str(e))

================================================================
File: gui\workers.py
================================================================
import os
import numpy as np
import pandas as pd
import skimage.io
from PyQt5 import QtCore
import neuron_tracker_core as ntc

class AnalysisWorker(QtCore.QObject):
    progress = QtCore.pyqtSignal(float)
    message = QtCore.pyqtSignal(str)
    finished = QtCore.pyqtSignal(bool, str)  # success, error_msg

    def __init__(self, input_file, output_basename, args):
        super().__init__()
        self.input_file = input_file
        self.output_basename = output_basename
        self.args = args

    @QtCore.pyqtSlot()
    def run(self):
        try:
            self.message.emit(f"Loading data from {self.input_file}...")
            data = skimage.io.imread(self.input_file)
            data = ntc.rescale(data, 0.0, 1.0)
            T = data.shape[0]

            # --- Robust callback wrappers (core may send str, float, tuple, etc.) ---
            stage_min = 0.0
            stage_max = 0.0

            def _set_stage(a, b):
                nonlocal stage_min, stage_max
                stage_min, stage_max = float(a), float(b)

            def _log_progress(x):
                # If core sends numeric progress, map it into the current stage range.
                try:
                    if isinstance(x, (int, float, np.floating)):
                        v = float(x)
                        if 0.0 <= v <= 1.0:
                            self.progress.emit(stage_min + v * (stage_max - stage_min))
                            return
                except Exception:
                    pass

                # Otherwise treat as message-like update.
                try:
                    self.message.emit(str(x))
                except Exception:
                    self.message.emit("Progress update (unprintable)")

            self.message.emit("Stage 1/4: Detecting features...")
            _set_stage(0.00, 0.25)
            ims, ids, trees, blob_lists = ntc.process_frames(
                data,
                sigma1=self.args["sigma1"],
                sigma2=self.args["sigma2"],
                blur_sigma=self.args["blur_sigma"],
                max_features=self.args["max_features"],
                progress_callback=_log_progress,
            )

            self.message.emit("Stage 2/4: Building trajectories...")
            _set_stage(0.25, 0.50)
            graph, subgraphs = ntc.build_trajectories(
                blob_lists,
                trees,
                ids,
                search_range=self.args["search_range"],
                cone_radius_base=self.args["cone_radius_base"],
                cone_radius_multiplier=self.args["cone_radius_multiplier"],
                progress_callback=_log_progress,
            )

            self.message.emit("Stage 3/4: Pruning trajectories...")
            _set_stage(0.50, 0.70)
            pruned_subgraphs, reverse_ids = ntc.prune_trajectories(
                graph,
                subgraphs,
                ids,
                progress_callback=_log_progress,
            )

            self.message.emit("Stage 4/4: Extracting traces & Computing Metrics...")
            
            mode = self.args.get('mode', 'strict')

            # Use return_candidates=True to get rich object data
            _set_stage(0.70, 1.00)
            candidates = ntc.extract_and_interpolate_data(
                ims,
                pruned_subgraphs,
                reverse_ids,
                min_trajectory_length=self.args["min_trajectory_length"],
                sampling_box_size=self.args["sampling_box_size"],
                sampling_sigma=self.args["sampling_sigma"],
                max_interpolation_distance=self.args["max_interpolation_distance"],
                progress_callback=_log_progress,
                mode=mode,
                return_candidates=True
            )

            # --- EXPLICIT GATING LOGIC ---
            accepted_candidates = []
            
            for c in candidates:
                # 1. Hard invariant: Must have data
                if c.trace is None:
                    continue

                # 2. Mode-specific Selection
                if mode == 'strict':
                    # Legacy contract: must pass all strict checks in core
                    if getattr(c, "accepted", False):
                        accepted_candidates.append(c)
                else:
                    # Scored contract: keep candidates with a usable trace AND spatially plausible track.
                    # This preserves post-hoc flexibility without admitting clearly broken tracks.
                    if getattr(c, "trace_extracted", False) and getattr(c, "is_valid_spatial", True):
                        accepted_candidates.append(c)

            if not accepted_candidates:
                raise RuntimeError("Processing complete, but no valid trajectories were found.")
            else:
                self.message.emit(
                    f"Processing complete. Saving {len(accepted_candidates)} trajectories."
                )

                coms_list = []
                trajectories_list = []
                metrics_data = []

                for i, cand in enumerate(accepted_candidates):
                    # --- HARD INVARIANTS ---
                    if cand.positions is None:
                        raise ValueError(
                            f"Candidate {i} has a trace but no positions, cannot save trajectories."
                        )
                    if cand.trace is None:
                        raise ValueError(
                            f"Candidate {i} has positions but no trace, cannot save trajectories."
                        )

                    # --- SAFETY ASSERTIONS ---
                    # Ensure alignment and shape integrity before saving
                    if cand.positions.shape != (T, 2):
                        raise ValueError(
                            f"Candidate {i} position shape mismatch: {cand.positions.shape} vs ({T}, 2)"
                        )
                    if cand.trace.shape != (T,):
                        raise ValueError(
                            f"Candidate {i} trace shape mismatch: {cand.trace.shape} vs ({T},)"
                        )

                    # --- Arrays ---
                    
                    coms_list.append(np.mean(cand.positions, axis=0))
                    trajectories_list.append(cand.positions)

                    # --- Metrics ---
                    m = getattr(cand, "metrics", None)
                    metrics_data.append({
                        'candidate_id': i,  # Stable index 0..N-1 matching arrays
                        'original_graph_id': getattr(cand, "id", np.nan),

                        'n_detected': getattr(m, "n_detected", np.nan),
                        'detected_fraction': getattr(m, "detected_fraction", np.nan),
                        'path_node_fraction': getattr(m, "path_node_fraction", np.nan),
                        'max_gap': getattr(m, "max_gap", np.nan),
                        'max_step': getattr(m, "max_step", np.nan),
                        'boundary_fail': getattr(m, "boundary_fail", np.nan),
                        'spatial_jitter_raw': getattr(m, "spatial_jitter_raw", np.nan),
                        'spatial_jitter_detrended': getattr(m, "spatial_jitter_detrended", np.nan),
                        'trace_snr_proxy': getattr(m, "trace_snr_proxy", np.nan),

                        'reject_reason': getattr(cand, "reject_reason", ""),
                        'is_valid_spatial': getattr(cand, "is_valid_spatial", np.nan),
                        'trace_extracted': getattr(cand, "trace_extracted", np.nan),
                    })

                # Convert lists to numpy arrays for saving
                com_arr = np.stack(coms_list, axis=0).astype(np.float32)
                
                H, W = data.shape[1], data.shape[2]
                
                if np.any((com_arr[:, 0] < 0) | (com_arr[:, 0] >= H) | (com_arr[:, 1] < 0) | (com_arr[:, 1] >= W)):
                    self.message.emit("Warning: COM coordinates fall outside image bounds, check (y,x) vs (x,y) convention in core.")
                
                traj_arr = np.stack(trajectories_list, axis=0).astype(np.float32)
                
                # Reconstruct traces.csv matrix
                intensity_matrix = np.column_stack([cand.trace for cand in accepted_candidates]).astype(np.float32)
                frame_index = np.arange(T, dtype=np.int32)
                traces_out = np.column_stack((frame_index, intensity_matrix))

                # ROI is saved as (x, y) for GUI consumption.
                # com_arr is computed from image coordinates: (y, x).
                y = com_arr[:, 0]
                x = com_arr[:, 1]
                roi_out = np.column_stack((x, y))
                
                # --- SAVE FILES ---
                np.savetxt(f"{self.output_basename}_roi.csv", roi_out, delimiter=",")
                self.message.emit("Saved center-of-mass data.")

                np.savetxt(f"{self.output_basename}_traces.csv", traces_out, delimiter=",")
                self.message.emit("Saved intensity traces.")

                np.save(f"{self.output_basename}_trajectories.npy", traj_arr)
                self.message.emit("Saved full trajectory data.")
                
                metrics_df = pd.DataFrame(metrics_data)
                metrics_df.to_csv(f"{self.output_basename}_metrics.csv", index=False)
                self.message.emit("Saved quality metrics.")

            self.progress.emit(1.0)
            self.finished.emit(True, "")
            
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            self.message.emit(f"--- ANALYSIS FAILED ---\nError: {e}")
            self.message.emit(tb)
            self.finished.emit(False, str(e))

class MovieLoaderWorker(QtCore.QObject):
    """Worker to load a movie file in a background thread."""
    finished = QtCore.pyqtSignal(object)  # Emits the loaded numpy array
    error = QtCore.pyqtSignal(str)

    def __init__(self, movie_path):
        super().__init__()
        self.movie_path = movie_path

    @QtCore.pyqtSlot()
    def run(self):
        try:
            if not self.movie_path or not os.path.exists(self.movie_path):
                raise FileNotFoundError("Movie file not found.")
            data = skimage.io.imread(self.movie_path)
            self.finished.emit(data)
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            self.error.emit(f"Failed to load movie: {e}\n{tb}")

================================================================
File: gui\__init__.py
================================================================


================================================================
File: gui\dialogs\registration.py
================================================================
import os
import json
import numpy as np
from PyQt5 import QtWidgets
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar,
)
from skimage.transform import ThinPlateSplineTransform

from gui.theme import get_icon

class RegistrationWindow(QtWidgets.QDialog):
    """
    Landmark-based TPS registration between atlas and each target.
    Writes *_warp_parameters.json exactly as original.
    """

    def __init__(self, parent, state, log_callback):
        super().__init__(parent)
        self.setWindowTitle("Atlas Registration Tool")
        self.resize(1200, 700)

        self.state = state
        self.atlas_path = self.state.atlas_roi_path
        # Make a copy so we can pop items without affecting the main state
        self.target_paths = list(self.state.target_roi_paths)
        self.log_callback = log_callback

        with open(self.atlas_path, "r") as f:
            self.atlas_rois = json.load(f)

        self.source_landmarks = []
        self.dest_landmarks = []
        self.warp_params = None

        main_layout = QtWidgets.QVBoxLayout(self)

        # Matplotlib
        self.fig = Figure()
        self.ax_atlas = self.fig.add_subplot(1, 2, 1)
        self.ax_target = self.fig.add_subplot(1, 2, 2)

        self.canvas = FigureCanvas(self.fig)
        toolbar = NavigationToolbar(self.canvas, self)

        main_layout.addWidget(toolbar)
        main_layout.addWidget(self.canvas)

        # Buttons
        btn_layout = QtWidgets.QHBoxLayout()
        self.calc_btn = QtWidgets.QPushButton(get_icon('fa5s.calculator'), "Calculate Warp")
        self.calc_btn.clicked.connect(self.calculate_warp)
        btn_layout.addWidget(self.calc_btn)

        self.save_btn = QtWidgets.QPushButton(get_icon('fa5s.save'), "Save Warp & Next")
        self.save_btn.setEnabled(False)
        self.save_btn.clicked.connect(self.save_and_next)
        btn_layout.addWidget(self.save_btn)

        reset_btn = QtWidgets.QPushButton(get_icon('fa5s.undo'), "Reset Landmarks")
        reset_btn.clicked.connect(self.reset_landmarks)
        btn_layout.addWidget(reset_btn)

        close_btn = QtWidgets.QPushButton(get_icon('fa5s.times'), "Close")
        close_btn.clicked.connect(self.reject)
        btn_layout.addWidget(close_btn)

        main_layout.addLayout(btn_layout)

        # MPL events
        self.cid = self.canvas.mpl_connect("button_press_event", self.on_click)

        self.load_next_target()

    def load_next_target(self):
        if not self.target_paths:
            self.log_callback("All targets have been registered.")
            self.accept()
            return

        self.current_target_path = self.target_paths.pop(0)
        self.log_callback(f"Registering: {os.path.basename(self.current_target_path)}")
        with open(self.current_target_path, "r") as f:
            self.target_rois = json.load(f)

        self.reset_landmarks()
        self.update_plots()
        self.setWindowTitle(
            f"Atlas Registration - {os.path.basename(self.current_target_path)} "
            f"({len(self.target_paths)} remaining)"
        )

    def reset_landmarks(self):
        self.source_landmarks = []
        self.dest_landmarks = []
        self.warp_params = None
        self.save_btn.setEnabled(False)
        self.update_plots()

    def on_click(self, event):
        if event.inaxes is None:
            return
        if event.button != 1:
            return

        # Left figure: atlas landmarks
        if event.inaxes == self.ax_atlas:
            if len(self.source_landmarks) > len(self.dest_landmarks):
                # force pairing in order
                return
            self.source_landmarks.append((event.xdata, event.ydata))
        # Right figure: target landmarks
        elif event.inaxes == self.ax_target:
            if len(self.dest_landmarks) >= len(self.source_landmarks):
                return
            self.dest_landmarks.append((event.xdata, event.ydata))

        self.update_plots()

    def update_plots(self, preview_shapes=None, warp_vectors=None):
        self.ax_atlas.clear()
        self.ax_target.clear()
        self.ax_atlas.set_title("Atlas SCN")
        self.ax_target.set_title("Target SCN")

        # --- Helper function to determine style based on mode ---
        def get_style(roi_mode):
            if roi_mode == "Phase Reference":
                return {"color": "cyan", "linestyle": "--", "linewidth": 1}
            elif roi_mode == "Exclude":
                return {"color": "red", "linestyle": "-", "linewidth": 1}
            else:
                # Default / Include
                return {"color": "black", "linestyle": "-", "linewidth": 2}
        # -------------------------------------------------------

        # Draw Atlas ROIs
        for roi in self.atlas_rois:
            xs, ys = zip(*roi["path_vertices"])
            style = get_style(roi.get("mode", "Include"))
            self.ax_atlas.plot(xs, ys, **style)

        # Draw Target ROIs
        for roi in getattr(self, "target_rois", []):
            xs, ys = zip(*roi["path_vertices"])
            style = get_style(roi.get("mode", "Include"))
            self.ax_target.plot(xs, ys, **style)
                        
        for i, (x, y) in enumerate(self.source_landmarks):
            self.ax_atlas.text(x, y, str(i + 1), color="red", ha="center", va="center", weight="bold")
        for i, (x, y) in enumerate(self.dest_landmarks):
            self.ax_target.text(x, y, str(i + 1), color="red", ha="center", va="center", weight="bold")
        if preview_shapes:
            for shape in preview_shapes:
                xs, ys = shape[:, 0], shape[:, 1]
                self.ax_atlas.plot(xs, ys, color="lime", linestyle="--", linewidth=1)
        if warp_vectors:
            ox, oy, dx, dy = warp_vectors
            self.ax_target.quiver(ox, oy, dx, dy, color="cyan", angles="xy", scale_units="xy", scale=1)
        for ax in (self.ax_atlas, self.ax_target):
            ax.set_aspect("equal", adjustable="box")
            ax.invert_yaxis()
            ax.autoscale_view()
        l1, r1 = self.ax_atlas.get_xlim()
        b1, t1 = self.ax_atlas.get_ylim()
        l2, r2 = self.ax_target.get_xlim()
        b2, t2 = self.ax_target.get_ylim()
        final_l, final_r = min(l1, l2), max(r1, r2)
        final_b, final_t = max(b1, b2), min(t1, t2)
        self.ax_atlas.set_xlim(final_l, final_r)
        self.ax_atlas.set_ylim(final_b, final_t)
        self.ax_target.set_xlim(final_l, final_r)
        self.ax_target.set_ylim(final_b, final_t)
        self.canvas.draw_idle()

    def calculate_warp(self):
        if len(self.source_landmarks) < 3 or len(self.source_landmarks) != len(self.dest_landmarks):
            self.log_callback("Error: Need 3 matched landmark pairs.")
            return
        source_pts = np.array(self.source_landmarks)
        dest_pts = np.array(self.dest_landmarks)
        sc = source_pts.mean(axis=0)
        dc = dest_pts.mean(axis=0)
        ssd = np.sqrt(np.mean(np.sum((source_pts - sc) ** 2, axis=1)))
        dsd = np.sqrt(np.mean(np.sum((dest_pts - dc) ** 2, axis=1)))
        if ssd == 0 or dsd == 0:
            self.log_callback("Error: Degenerate landmark configuration.")
            return
        source_norm = (source_pts - sc) / ssd
        dest_norm = (dest_pts - dc) / dsd
        
        tps = ThinPlateSplineTransform()
        tps.estimate(dest_norm, source_norm)
        self.warp_params = {
            "source_centroid": sc.tolist(), "dest_centroid": dc.tolist(),
            "source_scale": float(ssd), "dest_scale": float(dsd),
            "source_landmarks_norm": source_norm.tolist(), "dest_landmarks_norm": dest_norm.tolist(),
            "source_landmarks": self.source_landmarks, "destination_landmarks": self.dest_landmarks,
        }
        preview = []
        for roi in self.target_rois:
            verts = np.array(roi["path_vertices"])
            verts_norm = (verts - dc) / dsd
            warped_norm = tps(verts_norm)
            warped = warped_norm * ssd + sc
            preview.append(warped)
        dx = source_pts[:, 0] - dest_pts[:, 0]
        dy = source_pts[:, 1] - dest_pts[:, 1]
        warp_vectors = (dest_pts[:, 0], dest_pts[:, 1], dx, dy)
        self.update_plots(preview_shapes=preview, warp_vectors=warp_vectors)
        self.save_btn.setEnabled(True)
        self.log_callback("Warp computed; review preview and click 'Save Warp & Next'.")

    def save_and_next(self):
        if not self.warp_params:
            self.log_callback("Error: compute warp before saving.")
            return
        out_path = self.current_target_path.replace("_anatomical_roi.json", "_warp_parameters.json")
        try:
            with open(out_path, "w") as f:
                json.dump(self.warp_params, f, indent=4)
            self.log_callback(f"Saved warp parameters: {os.path.basename(out_path)}")
        except Exception as e:
            self.log_callback(f"Error saving warp file: {e}")
            return
        self.load_next_target()


================================================================
File: gui\dialogs\roi_drawer.py
================================================================
import os
import json
import numpy as np
from PyQt5 import QtWidgets
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar,
)
from matplotlib.patches import Polygon
from matplotlib.path import Path
from matplotlib.lines import Line2D

from gui.theme import get_icon

class RegionAttributesDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Region Attributes")
        self.layout = QtWidgets.QFormLayout(self)
        
        self.zone_id_spin = QtWidgets.QSpinBox()
        self.zone_id_spin.setRange(1, 20)
        self.layout.addRow("Zone ID (1=Dorsal, etc):", self.zone_id_spin)
        
        self.lobe_combo = QtWidgets.QComboBox()
        self.lobe_combo.addItems(["Left", "Right"])
        self.layout.addRow("Lobe:", self.lobe_combo)
        
        self.name_edit = QtWidgets.QLineEdit()
        self.name_edit.setPlaceholderText("e.g. Dorsal Shell")
        self.layout.addRow("Name (Optional):", self.name_edit)
        
        self.btns = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel
        )
        self.btns.accepted.connect(self.accept)
        self.btns.rejected.connect(self.reject)
        self.layout.addWidget(self.btns)

    def get_data(self):
        return {
            "zone_id": self.zone_id_spin.value(),
            "lobe": self.lobe_combo.currentText(),
            "name": self.name_edit.text()
        }

class ROIDrawerDialog(QtWidgets.QDialog):
    """
    ROI drawing dialog: include/exclude polygons, writes:
      - <basename>_anatomical_roi.json
      - <basename>_roi_filtered.csv
    Calls callback(filtered_indices, rois_dict_list)
    """

    def __init__(self, parent, bg_image, roi_data, output_basename, callback, vmin=None, vmax=None, is_region_mode=False):
        super().__init__(parent)
        self.setWindowTitle("Advanced ROI Definition Tool")
        self.resize(1100, 800)

        self.bg_image = bg_image
        self.roi_data = roi_data
        self.output_basename = output_basename
        self.callback = callback
        self.is_region_mode = is_region_mode  # Store the flag


        self.rois = []
        self.current_vertices = []
        self.current_line = None
        self.finished_artists = []  # Track artists for finished polygons
        self.mode = "Include"

        # Attempt to load existing anatomical ROI file
        if self.output_basename:
            json_path = f"{self.output_basename}_anatomical_roi.json"
            if os.path.exists(json_path):
                try:
                    with open(json_path, "r") as f:
                        self.rois = json.load(f)
                except Exception as e:
                    print(f"Error loading existing ROIs: {e}")

        # --- Layout Setup ---
        main_layout = QtWidgets.QHBoxLayout(self)

        # LEFT: Plot Area
        plot_widget = QtWidgets.QWidget()
        plot_layout = QtWidgets.QVBoxLayout(plot_widget)
        
        self.fig = Figure()
        self.ax = self.fig.add_subplot(111)
        self.ax.imshow(bg_image, cmap="gray", vmin=vmin, vmax=vmax)

        if roi_data is not None and len(roi_data) > 0:
            self.ax.plot(roi_data[:, 0], roi_data[:, 1],
                         ".", color="gray", markersize=2, alpha=0.5)

        self.ax.set_title("Click to Define ROI Polygon")
        self.canvas = FigureCanvas(self.fig)
        toolbar = NavigationToolbar(self.canvas, self)
        
        plot_layout.addWidget(toolbar)
        plot_layout.addWidget(self.canvas)
        
        main_layout.addWidget(plot_widget, stretch=3)

        # RIGHT: Control Panel
        ctrl_widget = QtWidgets.QWidget()
        ctrl_layout = QtWidgets.QVBoxLayout(ctrl_widget)
        
        # Instructions
        info = QtWidgets.QLabel(
            "<b>Instructions:</b><br>"
            "1. Select Mode below.<br>"
            "2. Left-click on image to draw.<br>"
            "3. Right-click to remove last point.<br>"
            "4. Click 'Finish Polygon' to save.<br><br>"
            "<b>To Delete:</b> Select from list and click Delete."
        )
        info.setWordWrap(True)
        ctrl_layout.addWidget(info)
        
        # Mode Selection
        mode_box = QtWidgets.QGroupBox("Drawing Mode")
        mode_layout = QtWidgets.QVBoxLayout(mode_box)
        self.include_btn = QtWidgets.QRadioButton("Include (Green)")
        self.exclude_btn = QtWidgets.QRadioButton("Exclude (Red)")
        self.ref_btn = QtWidgets.QRadioButton("Phase Ref (Blue)")
        self.ref_btn.setStyleSheet("color: blue; font-weight: bold;")
        
        # Phase Axis Button
        self.axis_btn = QtWidgets.QRadioButton("Phase Axis (Arrow)")
        self.axis_btn.setStyleSheet("color: magenta; font-weight: bold;")
        
        self.include_btn.setChecked(True)
        self.include_btn.toggled.connect(self.update_mode)
        self.exclude_btn.toggled.connect(self.update_mode)
        self.ref_btn.toggled.connect(self.update_mode)
        self.axis_btn.toggled.connect(self.update_mode)
        
        mode_layout.addWidget(self.include_btn)
        mode_layout.addWidget(self.exclude_btn)
        mode_layout.addWidget(self.ref_btn)
        mode_layout.addWidget(self.axis_btn)
        ctrl_layout.addWidget(mode_box)

        # Action Buttons
        self.finish_btn = QtWidgets.QPushButton(get_icon('fa5s.check'), "Finish Polygon")
        self.finish_btn.clicked.connect(self.finish_polygon)
        ctrl_layout.addWidget(self.finish_btn)

        # ROI List Management
        list_label = QtWidgets.QLabel("Defined ROIs:")
        ctrl_layout.addWidget(list_label)
        
        self.roi_list_widget = QtWidgets.QListWidget()
        self.roi_list_widget.itemSelectionChanged.connect(self.highlight_selected_roi)
        ctrl_layout.addWidget(self.roi_list_widget)
        
        self.delete_btn = QtWidgets.QPushButton(get_icon('fa5s.trash'), "Delete Selected ROI")
        self.delete_btn.clicked.connect(self.delete_selected_roi)
        ctrl_layout.addWidget(self.delete_btn)
        
        ctrl_layout.addStretch()
        
        # Final Confirm
        confirm_btn = QtWidgets.QPushButton(get_icon('fa5s.save'), "Save & Confirm All")
        confirm_btn.setStyleSheet("font-weight: bold; padding: 5px;")
        confirm_btn.clicked.connect(self.confirm_rois)
        ctrl_layout.addWidget(confirm_btn)

        main_layout.addWidget(ctrl_widget, stretch=1)

        self.cid = self.canvas.mpl_connect("button_press_event", self.on_click)
        
        # Draw initial state
        self.redraw_finished_rois()

    def redraw_finished_rois(self):
        for artist in self.finished_artists:
            artist.remove()
        self.finished_artists = []
        
        self.roi_list_widget.blockSignals(True)
        self.roi_list_widget.clear()

        style_map = {
            "Include": {"color": "lime", "linestyle": "-"},
            "Exclude": {"color": "red", "linestyle": "-"},
            "Phase Reference": {"color": "cyan", "linestyle": "--"},
            "Phase Axis": {"color": "magenta", "linestyle": "-", "marker": ">"} 
        }

        for i, roi in enumerate(self.rois):
            mode = roi.get("mode", "Include")
            verts = roi.get("path_vertices", [])
            if not verts:
                continue
            
            style = style_map.get(mode, style_map["Include"])
            
            if mode == "Phase Axis":
                xs, ys = zip(*verts)
                line = Line2D(
                    xs, ys, 
                    color=style["color"], 
                    linestyle=style["linestyle"], 
                    linewidth=2,
                    marker=style.get("marker"),
                    markersize=6,
                    picker=True
                )
                self.ax.add_artist(line)
                self.finished_artists.append(line)
            else:
                poly = Polygon(
                    verts, 
                    closed=True, 
                    fill=False, 
                    edgecolor=style["color"], 
                    linestyle=style["linestyle"], 
                    linewidth=2,
                    picker=True 
                )
                self.ax.add_patch(poly)
                self.finished_artists.append(poly)
            
            # Show Zone/Lobe in list
            label = f"{i+1}. {mode}"
            if "zone_id" in roi:
                label += f" (Zone {roi['zone_id']} {roi['lobe']})"
            item = QtWidgets.QListWidgetItem(label)
            
            self.roi_list_widget.addItem(item)
        
        self.roi_list_widget.blockSignals(False)
        self.canvas.draw_idle()

    def highlight_selected_roi(self):
        """Highlights the ROI selected in the list."""
        selected_rows = [x.row() for x in self.roi_list_widget.selectedIndexes()]
        idx = selected_rows[0] if selected_rows else -1
        
        style_map = {
            "Include": {"color": "lime", "linestyle": "-"},
            "Exclude": {"color": "red", "linestyle": "-"},
            "Phase Reference": {"color": "cyan", "linestyle": "--"},
            "Phase Axis": {"color": "magenta", "linestyle": "-", "marker": ">"}
        }
        
        for i, artist in enumerate(self.finished_artists):
            if i >= len(self.rois): 
                break
                
            roi = self.rois[i]
            mode = roi.get("mode", "Include")
            base_style = style_map.get(mode, style_map["Include"])
            
            # Check if artist is a Line2D (Axis) or Polygon (ROI)
            is_line = isinstance(artist, Line2D)
            
            if i == idx:
                # Highlight style
                if is_line:
                    artist.set_color("yellow")
                    artist.set_linewidth(3.5)
                else:
                    artist.set_edgecolor("yellow")
                    artist.set_linewidth(3.5)
                    
                artist.set_linestyle("-")
                artist.set_zorder(10)
            else:
                # Normal style
                if is_line:
                    artist.set_color(base_style["color"])
                    artist.set_linewidth(2)
                else:
                    artist.set_edgecolor(base_style["color"])
                    artist.set_linewidth(2)
                    
                artist.set_linestyle(base_style["linestyle"])
                artist.set_zorder(1)
                
        self.canvas.draw_idle()

    def delete_selected_roi(self):
        selected_rows = [x.row() for x in self.roi_list_widget.selectedIndexes()]
        if not selected_rows:
            QtWidgets.QMessageBox.information(self, "Info", "Please select an ROI from the list to delete.")
            return
        
        idx = selected_rows[0]
        
        # Remove from data
        self.rois.pop(idx)
        
        # Update UI
        self.redraw_finished_rois()

    def update_mode(self):
        if self.include_btn.isChecked():
            self.mode = "Include"
        elif self.exclude_btn.isChecked():
            self.mode = "Exclude"
        elif self.ref_btn.isChecked():
            self.mode = "Phase Reference"
        else:
            self.mode = "Phase Axis"
        self.update_plot()

    def update_plot(self):
        if self.current_line is not None:
            for artist in self.current_line:
                artist.remove()
        self.current_line = None

        color_map = {
            "Include": ("g-", "g+"),
            "Exclude": ("r-", "r+"),
            "Phase Reference": ("b-", "b+")
        }
        line_color, point_color = color_map.get(self.mode, ("g-", "g+"))

        if len(self.current_vertices) > 1:
            xs, ys = zip(*self.current_vertices)
            self.current_line = self.ax.plot(xs, ys, line_color)
        elif self.current_vertices:
            x, y = self.current_vertices[0]
            self.current_line = self.ax.plot(x, y, point_color)

        self.canvas.draw_idle()

    def on_click(self, event):
        if event.inaxes != self.ax:
            return
        if event.button == 1: # Left click
            if event.xdata is None or event.ydata is None:
                return
            self.current_vertices.append((float(event.xdata), float(event.ydata)))
            self.update_plot()
        elif event.button == 3: # Right click
            if self.current_vertices:
                self.current_vertices.pop()
                self.update_plot()

    def finish_polygon(self):
        # Logic: If it's a Polygon, we need > 2 points. If it's an Axis (Line), 2 points is enough.
        min_points = 2 if self.mode == "Phase Axis" else 3
        
        if len(self.current_vertices) >= min_points:
            
            # Region Tagging
            attributes = {}
            if self.is_region_mode and self.mode == "Include":
                # Pop up the dialog
                dlg = RegionAttributesDialog(self)
                if dlg.exec_() == QtWidgets.QDialog.Accepted:
                    attributes = dlg.get_data()
                else:
                    # User cancelled, abort polygon creation
                    return 

            # Only close the loop if it is NOT a Phase Axis
            if self.mode != "Phase Axis":
                self.current_vertices.append(self.current_vertices[0]) # Close loop
            
            roi_data = {
                "path_vertices": list(self.current_vertices),
                "mode": self.mode,
            }
            # Merge attributes (Zone ID, Lobe) into the ROI data
            roi_data.update(attributes)
            
            self.rois.append(roi_data)
            
            self.current_vertices = []
            if self.current_line is not None:
                for artist in self.current_line:
                    artist.remove()
                self.current_line = None
            
            self.redraw_finished_rois()
            self.ax.set_title(f"{len(self.rois)} ROI(s) defined.")

    def confirm_rois(self):
        # Separate the ROIs by their purpose
        anatomical_rois = [r for r in self.rois if r["mode"] in ("Include", "Exclude")]
        # Include Phase Axis here so it is passed back to the saver
        phase_ref_rois = [r for r in self.rois if r["mode"] in ("Phase Reference", "Phase Axis")]

        # Save ALL ROIs (Standard Mode only)
        all_rois_to_save = anatomical_rois + phase_ref_rois
        
        if all_rois_to_save and self.output_basename:
            filepath = f"{self.output_basename}_anatomical_roi.json"
            try:
                serializable = []
                for r in all_rois_to_save:
                    # Handle Line2D vs Polygon data structures if necessary
                    # But self.rois usually stores raw dicts, so this is fine.
                    serializable.append({
                        "path_vertices": r["path_vertices"], 
                        "mode": r["mode"]
                    })
                    
                with open(filepath, "w") as f:
                    json.dump(serializable, f, indent=4)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Save Error", f"Error saving anatomical ROI file:\n{e}")

        # Calculate Filtering (Only if we have cell data)
        filtered_indices = None
        
        # Check if roi_data exists
        if self.roi_data is not None:
            if anatomical_rois:
                final_mask = np.zeros(len(self.roi_data), dtype=bool)
                include_paths = [Path(r["path_vertices"]) for r in anatomical_rois if r["mode"] == "Include"]
                
                if include_paths:
                    for path in include_paths:
                        final_mask |= path.contains_points(self.roi_data)
                else:
                    # If only Excludes exist, start with everything included
                    final_mask[:] = True 

                for roi in anatomical_rois:
                    if roi["mode"] == "Exclude":
                        final_mask &= ~Path(roi["path_vertices"]).contains_points(self.roi_data)

                filtered_indices = np.where(final_mask)[0]

                if self.output_basename:
                    try:
                        np.savetxt(f"{self.output_basename}_roi_filtered.csv", self.roi_data[filtered_indices], delimiter=",")
                    except Exception as e:
                        QtWidgets.QMessageBox.warning(self, "Save Error", f"Error saving filtered ROI CSV:\n{e}")

        # Return results via callback
        if self.callback:
            self.callback(filtered_indices, anatomical_rois, phase_ref_rois)

        self.accept()


================================================================
File: gui\dialogs\warp_inspector.py
================================================================
import json
import numpy as np
from PyQt5 import QtWidgets
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar,
)

from gui.theme import get_icon

class WarpInspectorWindow(QtWidgets.QDialog):
    """
    Diagnostic visualization: original target vs warped (normalized atlas space),
    with option to overlay normalized original.
    """

    def __init__(self, parent, atlas_roi_path, target_roi_path,
                 original_points, warped_points,
                 original_points_norm, warped_points_norm,
                 warp_params, title):
        super().__init__(parent)
        self.setWindowTitle(f"Warp Inspector - {title}")
        self.resize(1200, 700)

        self.atlas_roi_path = atlas_roi_path
        self.target_roi_path = target_roi_path
        self.original_points = original_points
        self.warped_points = warped_points
        self.original_points_norm = original_points_norm
        self.warped_points_norm = warped_points_norm
        self.warp_params = warp_params
        self.overlay_visible = False
        self.overlay_artists = []
        main_layout = QtWidgets.QVBoxLayout(self)
        self.fig = Figure(figsize=(12, 6))
        self.ax_before = self.fig.add_subplot(1, 2, 1)
        self.ax_after = self.fig.add_subplot(1, 2, 2)
        self.canvas = FigureCanvas(self.fig)
        toolbar = NavigationToolbar(self.canvas, self)
        main_layout.addWidget(toolbar)
        main_layout.addWidget(self.canvas)
        btn_layout = QtWidgets.QHBoxLayout()
        self.overlay_btn = QtWidgets.QCheckBox("Show Normalized Original Data as Overlay")
        self.overlay_btn.stateChanged.connect(self.toggle_overlay)
        btn_layout.addWidget(self.overlay_btn)
        close_btn = QtWidgets.QPushButton(get_icon('fa5s.times'), "Close")
        close_btn.clicked.connect(self.accept)
        btn_layout.addWidget(close_btn)
        main_layout.addLayout(btn_layout)
        self.draw_plots()

    def draw_plots(self):
        self.ax_before.clear()
        self.ax_before.set_title("Before Warp: Original Target")
        with open(self.target_roi_path, "r") as f: trois = json.load(f)
        for roi in trois:
            xs, ys = zip(*roi["path_vertices"])
            self.ax_before.plot(xs, ys, color="black", linewidth=2)
        self.ax_before.scatter(self.original_points[:, 0], self.original_points[:, 1], s=10, alpha=0.7, c="blue")
        self.ax_before.set_aspect("equal", adjustable="box")
        self.ax_before.invert_yaxis()
        self.ax_after.clear()
        self.ax_after.set_title("After Warp: Normalized Atlas Space")
        sc = np.array(self.warp_params["source_centroid"])
        ss = self.warp_params["source_scale"]
        with open(self.atlas_roi_path, "r") as f: arois = json.load(f)
        for roi in arois:
            verts = (np.array(roi["path_vertices"]) - sc) / ss
            self.ax_after.plot(verts[:, 0], verts[:, 1], color="black", linewidth=2)
        self.ax_after.scatter(self.warped_points_norm[:, 0], self.warped_points_norm[:, 1], s=10, alpha=0.7, c="red")
        self.ax_after.set_aspect("equal", adjustable="box")
        self.ax_after.invert_yaxis()
        self.toggle_overlay()
        self.canvas.draw_idle()

    def toggle_overlay(self):
        for a in self.overlay_artists: a.remove()
        self.overlay_artists.clear()
        if self.overlay_btn.isChecked():
            dc = np.array(self.warp_params["dest_centroid"])
            ds = self.warp_params["dest_scale"]
            with open(self.target_roi_path, "r") as f: trois = json.load(f)
            for roi in trois:
                verts_norm = (np.array(roi["path_vertices"]) - dc) / ds
                line = self.ax_after.plot(verts_norm[:, 0], verts_norm[:, 1], color="blue", linestyle="--", linewidth=1, alpha=0.5)[0]
                self.overlay_artists.append(line)
            scatter = self.ax_after.scatter(self.original_points_norm[:, 0], self.original_points_norm[:, 1], s=10, alpha=0.3, c="blue", marker="x")
            self.overlay_artists.append(scatter)
        self.ax_after.autoscale_view()
        self.canvas.draw_idle()


================================================================
File: gui\panels\apply_warp.py
================================================================
import os
import json
import numpy as np
from PyQt5 import QtWidgets, QtCore
from skimage.transform import ThinPlateSplineTransform
from gui.dialogs.warp_inspector import WarpInspectorWindow

from gui.theme import get_icon

class ApplyWarpPanel(QtWidgets.QWidget):
    def __init__(self, main_window):
        super().__init__(main_window)
        self.mw = main_window
        self.state = main_window.state
        self.init_ui()
        self.connect_signals()

    def init_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        box = QtWidgets.QGroupBox("Apply Warp Setup")
        b = QtWidgets.QVBoxLayout(box)
        self.warp_list = QtWidgets.QListWidget()
        self.warp_list.setSelectionMode(
            QtWidgets.QAbstractItemView.ExtendedSelection
        )
        b.addWidget(self.warp_list)
        row = QtWidgets.QHBoxLayout()
        self.btn_add_warp = QtWidgets.QPushButton(get_icon('fa5s.plus'), "Add Warp Parameter File(s)...")
        self.btn_remove_warp = QtWidgets.QPushButton(get_icon('fa5s.minus'), "Remove Selected")
        row.addWidget(self.btn_add_warp)
        row.addWidget(self.btn_remove_warp)
        b.addLayout(row)
        row2 = QtWidgets.QHBoxLayout()
        self.btn_inspect_warp = QtWidgets.QPushButton(get_icon('fa5s.search'), "Inspect Selected Warp...")
        self.btn_inspect_warp.setEnabled(False)
        self.btn_apply_warp = QtWidgets.QPushButton(get_icon('fa5s.check-double'), "Apply All Warp(s)")
        self.btn_apply_warp.setEnabled(False)
        row2.addWidget(self.btn_inspect_warp)
        row2.addWidget(self.btn_apply_warp)
        b.addLayout(row2)
        layout.addWidget(box)
        layout.addStretch(1)

    def connect_signals(self):
        self.btn_add_warp.clicked.connect(self.add_warp_files)
        self.btn_remove_warp.clicked.connect(self.remove_warp_file)
        self.warp_list.itemSelectionChanged.connect(self.check_apply_warp_buttons_state)
        self.btn_apply_warp.clicked.connect(self.apply_warps)
        self.btn_inspect_warp.clicked.connect(self.inspect_warp)

    def add_warp_files(self):
        start_dir = self.mw._get_last_dir()
        files, _ = QtWidgets.QFileDialog.getOpenFileNames(
            self,
            "Select Warp Parameter Files",
            start_dir,
            "Warp Parameters (*_warp_parameters.json)",
        )
        if not files:
            return
        self.mw._set_last_dir(files[0])
        for f in files:
            if f not in self.state.warp_param_paths:
                self.state.warp_param_paths.append(f)
                self.warp_list.addItem(f)
        self.check_apply_warp_buttons_state()

    def remove_warp_file(self):
        for item in self.warp_list.selectedItems():
            row = self.warp_list.row(item)
            path = self.warp_list.item(row).text()
            if path in self.state.warp_param_paths:
                self.state.warp_param_paths.remove(path)
            self.warp_list.takeItem(row)
        self.check_apply_warp_buttons_state()

    def check_apply_warp_buttons_state(self):
        total = len(self.state.warp_param_paths)
        selected = len(self.warp_list.selectedItems())
        self.btn_apply_warp.setEnabled(total > 0)
        self.btn_inspect_warp.setEnabled(selected == 1)

    def apply_warps(self):
        if not self.state.warp_param_paths:
            self.mw.log_message("No warp files selected.")
            return
        self.mw.log_message(f"Applying {len(self.state.warp_param_paths)} warp(s)...")
        for warp_file in self.state.warp_param_paths:
            try:
                with open(warp_file, "r") as f: warp = json.load(f)
                roi_file = warp_file.replace("_warp_parameters.json", "_roi_filtered.csv")
                if not os.path.exists(roi_file):
                    self.mw.log_message(f"Missing _roi_filtered.csv for {os.path.basename(warp_file)}")
                    continue
                roi_pts = np.loadtxt(roi_file, delimiter=",")
                tps = ThinPlateSplineTransform()
                tps.estimate(np.array(warp["dest_landmarks_norm"]), np.array(warp["source_landmarks_norm"]))
                dc = np.array(warp["dest_centroid"])
                ds = warp["dest_scale"]
                sc = np.array(warp["source_centroid"])
                ss = warp["source_scale"]
                pts_norm = (roi_pts - dc) / ds
                warped_norm = tps(pts_norm)
                warped_pts = warped_norm * ss + sc
                out = roi_file.replace("_roi_filtered.csv", "_roi_warped.csv")
                np.savetxt(out, warped_pts, delimiter=",")
                self.mw.log_message(f"Created {os.path.basename(out)}")
            except Exception as e:
                self.mw.log_message(f"Failed to process {os.path.basename(warp_file)}: {e}")
        self.mw.log_message("Warp application complete.")
        self.mw.update_workflow_from_files()

    def inspect_warp(self):
        items = self.warp_list.selectedItems()
        if not items:
            self.mw.log_message("Select a warp file to inspect.")
            return
        warp_file = items[0].text()
        try:
            if not self.state.atlas_roi_path or not os.path.exists(self.state.atlas_roi_path):
                base_dir = os.path.dirname(warp_file)
                potential_atlas = os.path.join(base_dir, "atlas_anatomical_roi.json")
                if os.path.exists(potential_atlas):
                    self.state.atlas_roi_path = potential_atlas
                    self.mw.register_panel.atlas_path_edit.setText(potential_atlas)
                    self.mw.log_message(f"Auto-detected atlas: {os.path.basename(potential_atlas)}")
                else:
                    raise ValueError("Atlas file not set. Please select one in the 'Atlas Registration' panel.")
            
            target_roi_filtered = warp_file.replace("_warp_parameters.json", "_roi_filtered.csv")
            target_anatomical = warp_file.replace("_warp_parameters.json", "_anatomical_roi.json")
            if not os.path.exists(target_roi_filtered): raise FileNotFoundError(f"Missing _roi_filtered.csv for {os.path.basename(warp_file)}")
            if not os.path.exists(target_anatomical): raise FileNotFoundError(f"Missing _anatomical_roi.json for {os.path.basename(warp_file)}")
            
            with open(warp_file, "r") as f: warp = json.load(f)
            orig_pts = np.loadtxt(target_roi_filtered, delimiter=",")
            tps = ThinPlateSplineTransform()
            tps.estimate(np.array(warp["dest_landmarks_norm"]), np.array(warp["source_landmarks_norm"]))
            dc = np.array(warp["dest_centroid"])
            ds = warp["dest_scale"]
            sc = np.array(warp["source_centroid"])
            ss = warp["source_scale"]
            pts_norm = (orig_pts - dc) / ds
            warped_norm = tps(pts_norm)
            warped_pts = warped_norm * ss + sc
            
            dlg = WarpInspectorWindow(
                self.mw, self.state.atlas_roi_path, target_anatomical,
                orig_pts, warped_pts, pts_norm, warped_norm, warp,
                title=os.path.basename(target_roi_filtered)
            )
            dlg.exec_()
        except Exception as e:
            self.mw.log_message(f"Error during warp inspection: {e}")


================================================================
File: gui\panels\atlas_registration.py
================================================================
import os
import json
import numpy as np

from PyQt5 import QtWidgets, QtCore
from gui.dialogs.registration import RegistrationWindow
from gui.dialogs.roi_drawer import ROIDrawerDialog
from matplotlib.path import Path
from gui.theme import get_icon

class AtlasRegistrationPanel(QtWidgets.QWidget):
    def __init__(self, main_window):
        super().__init__(main_window)
        self.mw = main_window
        self.state = main_window.state
        self.init_ui()
        self.connect_signals()

    def init_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        box = QtWidgets.QGroupBox("Atlas Registration Setup")
        b = QtWidgets.QVBoxLayout(box)
        
        row = QtWidgets.QHBoxLayout()
        self.btn_select_atlas = QtWidgets.QPushButton(get_icon('fa5s.map'), "Select Atlas...")
        self.atlas_path_edit = QtWidgets.QLineEdit()
        self.atlas_path_edit.setReadOnly(True)
        
        # Edit Button
        self.btn_edit_atlas = QtWidgets.QPushButton(get_icon('fa5s.pen'), "Edit Atlas / Add Axis")
        self.btn_edit_atlas.setEnabled(False) # Disabled until atlas is selected
        
        row.addWidget(self.btn_select_atlas)
        row.addWidget(self.btn_edit_atlas)
        row.addWidget(self.atlas_path_edit)
        b.addLayout(row)
        
        self.target_list = QtWidgets.QListWidget()
        b.addWidget(self.target_list)
        row_btn = QtWidgets.QHBoxLayout()
        self.btn_add_targets = QtWidgets.QPushButton(get_icon('fa5s.plus'), "Add Target(s)...")
        self.btn_remove_target = QtWidgets.QPushButton(get_icon('fa5s.minus'), "Remove Selected")
        row_btn.addWidget(self.btn_add_targets)
        row_btn.addWidget(self.btn_remove_target)
        b.addLayout(row_btn)
        self.btn_begin_reg = QtWidgets.QPushButton(get_icon('fa5s.play-circle'), "Begin Registration...")
        self.btn_begin_reg.setEnabled(False)
        b.addWidget(self.btn_begin_reg)
        layout.addWidget(box)
        layout.addStretch(1)

    def connect_signals(self):
        self.btn_select_atlas.clicked.connect(self.select_atlas)
        self.btn_edit_atlas.clicked.connect(self.edit_atlas)
        self.btn_add_targets.clicked.connect(self.add_targets)
        self.btn_remove_target.clicked.connect(self.remove_target)
        self.btn_begin_reg.clicked.connect(self.begin_registration)

    def select_atlas(self):
        start_dir = self.mw._get_last_dir()
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self,
            "Select Atlas ROI File",
            start_dir,
            "Anatomical ROI files (*_anatomical_roi.json)",
        )
        if not path:
            return
        self.mw._set_last_dir(path)
        self.state.atlas_roi_path = path
        self.atlas_path_edit.setText(path)
        self.btn_edit_atlas.setEnabled(True)
        self._update_reg_button_state()

    def edit_atlas(self):
        path = self.state.atlas_roi_path
        if not path or not os.path.exists(path):
            return

        try:
            with open(path, 'r') as f:
                rois = json.load(f)
        except Exception as e:
            self.mw.log_message(f"Error loading atlas: {e}")
            return

        # 1. Calculate Bounding Box
        all_x = []
        all_y = []
        for r in rois:
            pts = np.array(r['path_vertices'])
            all_x.extend(pts[:, 0])
            all_y.extend(pts[:, 1])
            
        if not all_x:
            width, height = 1000, 1000
        else:
            pad = 50
            max_x = max(all_x) + pad
            max_y = max(all_y) + pad
            width = int(max_x)
            height = int(max_y)
        
        # 2. Create Blank Image
        bg_image = np.zeros((height, width)) 
        
        # 3. Define callback to save changes
        def save_callback(indices, updated_rois, updated_refs):
            final_list = []
            if updated_rois: final_list.extend(updated_rois)
            if updated_refs: final_list.extend(updated_refs)
            
            serializable = []
            for r in final_list:
                verts = r["path_vertices"]
                if hasattr(verts, 'tolist'): verts = verts.tolist()
                elif isinstance(verts, np.ndarray): verts = verts.tolist()
                
                item = {
                    "path_vertices": verts,
                    "mode": r["mode"]
                }
                serializable.append(item)
                
            try:
                with open(path, 'w') as f:
                    json.dump(serializable, f, indent=4)
                self.mw.log_message(f"Atlas updated: {os.path.basename(path)}")
            except Exception as e:
                self.mw.log_message(f"Failed to save atlas: {e}")

        # 4. Launch Dialog
        dlg = ROIDrawerDialog(
            self.mw,
            bg_image,
            None, # No cell dots
            None, # No basename needed, we handle save manually
            save_callback, 
            vmin=0, vmax=1
        )
        
        dlg.rois = rois 
        dlg.redraw_finished_rois()
        
        dlg.exec_()

    def add_targets(self):
        start_dir = self.mw._get_last_dir()
        files, _ = QtWidgets.QFileDialog.getOpenFileNames(
            self,
            "Select Target ROI Files",
            start_dir,
            "Anatomical ROI files (*_anatomical_roi.json)",
        )
        if not files:
            return
        self.mw._set_last_dir(files[0])
        for f in files:
            if f not in self.state.target_roi_paths:
                self.state.target_roi_paths.append(f)
                self.target_list.addItem(f)
        self._update_reg_button_state()

    def remove_target(self):
        for item in self.target_list.selectedItems():
            row = self.target_list.row(item)
            path = self.target_list.item(row).text()
            if path in self.state.target_roi_paths:
                self.state.target_roi_paths.remove(path)
            self.target_list.takeItem(row)
        self._update_reg_button_state()

    def _update_reg_button_state(self):
        has_atlas = bool(self.state.atlas_roi_path)
        has_targets = len(self.state.target_roi_paths) > 0
        self.btn_begin_reg.setEnabled(has_atlas and has_targets)

    def begin_registration(self):
        if not self.state.atlas_roi_path or not self.state.target_roi_paths: return
        dlg = RegistrationWindow(self.mw, self.state, self.mw.log_message)
        dlg.exec_()
        self.mw.update_workflow_from_files()


================================================================
File: gui\panels\group_view.py
================================================================
import os
import json
import numpy as np
import pandas as pd
from PyQt5 import QtWidgets, QtCore, QtGui
from matplotlib.path import Path
from scipy.stats import circmean, f as f_dist
from skimage.draw import polygon as draw_polygon

from gui.utils import Tooltip, add_mpl_to_tab, clear_layout, project_points_to_polyline
from gui.viewers import GroupScatterViewer, GroupAverageMapViewer, PhaseGradientViewer, RegionResultViewer
from gui.statistics import watson_williams_f
from gui.dialogs.roi_drawer import ROIDrawerDialog
from gui.theme import get_icon

class GroupViewPanel(QtWidgets.QWidget):
    def __init__(self, main_window):
        super().__init__(main_window)
        self.mw = main_window
        self.state = main_window.state
        self.zones_polygons_map = {} 
        self.init_ui()
        self.connect_signals()

    def init_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        box = QtWidgets.QGroupBox("Group Data Setup")
        b = QtWidgets.QVBoxLayout(box)
        
        self.group_list = QtWidgets.QTreeWidget()
        self.group_list.setHeaderLabels(["File Path", "Group"])
        self.group_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        b.addWidget(self.group_list)
        
        row = QtWidgets.QHBoxLayout()
        self.btn_add_group = QtWidgets.QPushButton(get_icon('fa5s.plus'), "Add Warped ROI File(s)...")
        self.btn_remove_group = QtWidgets.QPushButton(get_icon('fa5s.minus'), "Remove Selected")
        row.addWidget(self.btn_add_group)
        row.addWidget(self.btn_remove_group)
        b.addLayout(row)
        
        assign_row = QtWidgets.QHBoxLayout()
        self.btn_assign_control = QtWidgets.QPushButton("Set Selected as Control")
        self.btn_assign_exp = QtWidgets.QPushButton("Set Selected as Experiment")
        assign_row.addWidget(self.btn_assign_control)
        assign_row.addWidget(self.btn_assign_exp)
        b.addLayout(assign_row)
        
        param_box = QtWidgets.QGroupBox("Continuous Map Parameters")
        param_layout = QtWidgets.QFormLayout(param_box)
        self.group_grid_res_edit = QtWidgets.QLineEdit("50")
        self.group_smooth_check = QtWidgets.QCheckBox("Smooth to fill empty bins")
        param_layout.addRow("Grid Resolution:", self.group_grid_res_edit)
        param_layout.addRow(self.group_smooth_check)
        b.addWidget(param_box)        
        
        region_box = QtWidgets.QGroupBox("Regional Analysis Setup")
        region_layout = QtWidgets.QFormLayout(region_box)
        
        atlas_box = QtWidgets.QWidget()
        atlas_layout = QtWidgets.QHBoxLayout(atlas_box)
        atlas_layout.setContentsMargins(0, 0, 0, 0)
        self.btn_load_atlas = QtWidgets.QPushButton(get_icon('fa5s.map'), "Load Atlas Template...")
        self.atlas_path_label = QtWidgets.QLineEdit()
        self.atlas_path_label.setPlaceholderText("No Atlas Loaded")
        self.atlas_path_label.setReadOnly(True)
        atlas_layout.addWidget(self.btn_load_atlas)
        atlas_layout.addWidget(self.atlas_path_label)
        region_layout.addRow("Atlas Template:", atlas_box)
        
        self.btn_define_regions = QtWidgets.QPushButton(get_icon('fa5s.draw-polygon'), "Define Analysis Regions...")
        self.region_status_label = QtWidgets.QLabel("No regions defined")
        self.region_status_label.setStyleSheet("color: gray; font-style: italic;")
        region_layout.addRow(self.btn_define_regions, self.region_status_label)

        self.min_region_cells_spin = QtWidgets.QSpinBox()
        self.min_region_cells_spin.setRange(1, 100)
        self.min_region_cells_spin.setValue(10)
        region_layout.addRow("Min Cells / Region / Animal:", self.min_region_cells_spin)

        self.min_animals_spin = QtWidgets.QSpinBox()
        self.min_animals_spin.setRange(2, 50)
        self.min_animals_spin.setValue(3)
        region_layout.addRow("Min Animals / Group (Stats):", self.min_animals_spin)

        b.addWidget(region_box)
        
        self.btn_view_group = QtWidgets.QPushButton(get_icon('fa5s.chart-pie'), "Generate Group Visualizations")
        Tooltip.install(self.btn_view_group, "Runs Continuous Grid analysis, Gradient analysis (if axes present), and Regional Statistical analysis.")
        self.btn_view_group.setEnabled(False)
        b.addWidget(self.btn_view_group)
        
        layout.addWidget(box)
        layout.addStretch(1)

    def connect_signals(self):
        self.btn_add_group.clicked.connect(self.add_group_files)
        self.btn_remove_group.clicked.connect(self.remove_group_file)
        self.btn_view_group.clicked.connect(self.generate_group_visualizations)
        self.btn_load_atlas.clicked.connect(self.load_atlas_template)
        self.btn_assign_control.clicked.connect(lambda: self.assign_group("Control"))
        self.btn_assign_exp.clicked.connect(lambda: self.assign_group("Experiment"))
        self.btn_define_regions.clicked.connect(self.define_regions)
        self.mw.btn_export_data.clicked.connect(self.export_current_data)
    
    def assign_group(self, group_name: str):
        selected_items = self.group_list.selectedItems()
        if not selected_items:
            QtWidgets.QMessageBox.information(self, "No Selection", "Please select one or more files to assign.")
            return
        for item in selected_items:
            item.setText(1, group_name)
            item.setForeground(1, QtGui.QColor('blue') if group_name == "Control" else QtGui.QColor('red'))
    
    def define_regions(self):
        atlas_path = self.state.atlas_roi_path
        if not atlas_path or not os.path.exists(atlas_path):
            QtWidgets.QMessageBox.warning(self, "No Atlas", "Please load an Atlas Template first.")
            return

        try:
            with open(atlas_path, 'r') as f:
                atlas_rois = json.load(f)
            
            all_verts = []
            for r in atlas_rois:
                if 'path_vertices' in r: all_verts.extend(r['path_vertices'])
            
            if not all_verts: return
            all_verts = np.array(all_verts)
            max_x, max_y = np.max(all_verts[:, 0]), np.max(all_verts[:, 1])
            bg_image = np.zeros((int(max_y) + 50, int(max_x) + 50), dtype=float)
            
            for r in atlas_rois:
                if r.get('mode') == 'Include':
                    poly = np.array(r['path_vertices'])
                    rr, cc = draw_polygon(poly[:, 1], poly[:, 0], shape=bg_image.shape)
                    bg_image[rr, cc] = 0.3 
            
            region_file = atlas_path.replace('_anatomical_roi.json', '_anatomical_regions.json')
            existing_regions = []
            if os.path.exists(region_file):
                with open(region_file, 'r') as f: existing_regions = json.load(f)

            def save_callback(indices, rois_list, refs_list):
                final_list = (rois_list or []) + (refs_list or [])
                if not final_list: return
                serializable = []
                for r in final_list:
                    verts = r["path_vertices"]
                    if hasattr(verts, 'tolist'): verts = verts.tolist()
                    elif isinstance(verts, np.ndarray): verts = verts.tolist()
                    item = {"path_vertices": verts, "mode": r["mode"]}
                    for k in ["zone_id", "lobe", "name"]:
                        if k in r: item[k] = r[k]
                    serializable.append(item)
                with open(region_file, 'w') as f: json.dump(serializable, f, indent=4)
                self.mw.log_message(f"Saved {len(serializable)} regions.")
                self.region_status_label.setText(f"{len(serializable)} regions loaded.")
                self.region_status_label.setStyleSheet("color: green; font-weight: bold;")

            dlg = ROIDrawerDialog(self.mw, bg_image, None, None, save_callback, vmin=0, vmax=1, is_region_mode=True)
            if existing_regions:
                dlg.rois = existing_regions
                dlg.redraw_finished_rois()
            dlg.exec_()

        except Exception as e:
            self.mw.log_message(f"Error launching region definition: {e}")

    def load_atlas_template(self):
        start_dir = self.mw._get_last_dir()
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Select Master Atlas ROI", start_dir, "JSON files (*.json)"
        )
        if not path: return
        self.mw._set_last_dir(path)
        self.state.atlas_roi_path = path
        self.atlas_path_label.setText(os.path.basename(path))
        
        region_file = path.replace('_anatomical_roi.json', '_anatomical_regions.json')
        if os.path.exists(region_file):
            with open(region_file, 'r') as f: regions = json.load(f)
            self.region_status_label.setText(f"{len(regions)} regions found.")
            self.region_status_label.setStyleSheet("color: green;")

    def add_group_files(self):
        start_dir = self.mw._get_last_dir()
        files, _ = QtWidgets.QFileDialog.getOpenFileNames(
            self, "Select Warped ROI Files", start_dir, "Warped ROI files (*_roi_warped.csv)"
        )
        if not files: return
        self.mw._set_last_dir(files[0])
        for f in files:
            if f not in self.state.group_data_paths:
                self.state.group_data_paths.append(f)
                item = QtWidgets.QTreeWidgetItem(self.group_list)
                item.setText(0, f)
                item.setText(1, "Unassigned")
        self._update_group_view_button()

    def remove_group_file(self):
        selected_items = self.group_list.selectedItems()
        for item in selected_items:
            path = item.text(0)
            if path in self.state.group_data_paths:
                self.state.group_data_paths.remove(path)
            (item.parent() or self.group_list.invisibleRootItem()).removeChild(item)
        self._update_group_view_button()

    def _update_group_view_button(self):
        self.btn_view_group.setEnabled(len(self.state.group_data_paths) > 0)

    def generate_group_visualizations(self):
        self.mw.log_message("--- Starting Group Analysis ---")
        
        if not self.state.group_data_paths: return
        atlas_path = self.state.atlas_roi_path
        if not atlas_path:
            self.mw.log_message("Error: No Atlas Template loaded.")
            return

        region_file = atlas_path.replace('_anatomical_roi.json', '_anatomical_regions.json')
        if not os.path.exists(region_file):
            self.mw.log_message(f"Error: Regions file not found. Please Define Regions first.")
            return

        try:
            with open(region_file, 'r') as f: raw_regions = json.load(f)
            self.zones = {} 
            self.zones_polygons_map = {} 
            
            for r in raw_regions:
                if 'zone_id' not in r: continue
                zid = r['zone_id']
                if zid not in self.zones:
                    self.zones[zid] = {'name': r.get('name', f"Zone {zid}"), 'polygons': []}
                    self.zones_polygons_map[zid] = []
                
                path_obj = Path(np.array(r['path_vertices']))
                self.zones[zid]['polygons'].append(path_obj)
                self.zones_polygons_map[zid].append(path_obj)
            
            self.mw.log_message(f"Loaded {len(self.zones)} anatomical zones.")
        except Exception as e:
            self.mw.log_message(f"Error parsing regions: {e}")
            return

        all_dfs = []
        try:
            group_map = {}
            root = self.group_list.invisibleRootItem()
            for i in range(root.childCount()):
                item = root.child(i)
                group_map[item.text(0)] = item.text(1)

            for roi_path in self.state.group_data_paths:
                base = os.path.basename(roi_path).replace('_roi_warped.csv', '')
                group = group_map.get(roi_path, "Unassigned")
                if group not in ["Control", "Experiment"]: continue
                
                rhythm_path = roi_path.replace("_roi_warped.csv", "_rhythm_results.csv")
                if not os.path.exists(rhythm_path): 
                     self.mw.log_message(f"Skipping {base}: No rhythm results.")
                     continue
                
                coords = np.loadtxt(roi_path, delimiter=",")
                rhythm_df = pd.read_csv(rhythm_path)
                
                if len(coords) != len(rhythm_df):
                    self.mw.log_message(f"Warning: Length mismatch in {base}. Skipping.")
                    continue
                    
                mask = rhythm_df['Is_Rhythmic'].astype(bool).values
                if not np.any(mask): continue

                phases = rhythm_df['Phase_Hours'][mask].values
                periods = rhythm_df['Period_Hours'][mask].values
                phases_ct = (phases / periods) * 24.0
                
                df = pd.DataFrame({
                    'Animal': base, 'Group': group,
                    'X': coords[mask, 0], 'Y': coords[mask, 1],
                    'Phase_CT': phases_ct,
                    'Period_Hours': 24.0
                })
                all_dfs.append(df)

            if not all_dfs:
                self.mw.log_message("No valid animal data found.")
                return
            master_df = pd.concat(all_dfs, ignore_index=True)

            ctrl_phases = master_df[master_df['Group'] == 'Control']['Phase_CT'].values
            if len(ctrl_phases) == 0:
                self.mw.log_message("Error: No control cells found for normalization.")
                return
            
            rads = (ctrl_phases / 24.0) * (2 * np.pi)
            ref_rad = circmean(rads)
            ref_phase = (ref_rad / (2 * np.pi)) * 24.0
            
            master_df['Rel_Phase'] = (master_df['Phase_CT'] - ref_phase + 12.0) % 24.0 - 12.0
            self.mw.log_message(f"Normalized to Control Mean Phase: {ref_phase:.2f}h")

            self._generate_continuous_maps(master_df)
            self._generate_gradient_analysis(master_df)
            self._generate_regional_stats(master_df)

        except Exception as e:
            self.mw.log_message(f"Analysis Error: {e}")
            import traceback
            self.mw.log_message(traceback.format_exc())

    def _generate_continuous_maps(self, df):
        single_animal_tabs = [self.mw.heatmap_tab, self.mw.com_tab, self.mw.traj_tab, self.mw.phase_tab, self.mw.interp_tab]
        for tab in single_animal_tabs: self.mw.vis_tabs.setTabEnabled(self.mw.vis_tabs.indexOf(tab), False)
        
        try:
            grid_res = int(self.group_grid_res_edit.text())
            do_smooth = self.group_smooth_check.isChecked()
            
            x_min, x_max = df['X'].min(), df['X'].max()
            y_min, y_max = df['Y'].min(), df['Y'].max()
            width, height = x_max - x_min, y_max - y_min
            
            if width >= height:
                n_bins_x = grid_res
                bin_size = width / n_bins_x
                n_bins_y = max(1, int(round(height / bin_size)))
            else:
                n_bins_y = grid_res
                bin_size = height / n_bins_y
                n_bins_x = max(1, int(round(width / bin_size)))

            start_x = x_min - bin_size; end_x = x_max + bin_size
            start_y = y_min - bin_size; end_y = y_max + bin_size
            
            grid_x_bins = np.arange(start_x, end_x, bin_size)
            grid_y_bins = np.arange(start_y, end_y, bin_size)
            calc_x_bins = np.linspace(x_min, x_max, n_bins_x + 1)
            calc_y_bins = np.linspace(y_min, y_max, n_bins_y + 1)
            
            scatter_df = df.rename(columns={'Animal': 'Source_Animal', 'X': 'Warped_X', 'Y': 'Warped_Y', 'Rel_Phase': 'Relative_Phase_Hours'})
            fig_s, _ = add_mpl_to_tab(self.mw.group_scatter_tab)
            viewer_s = GroupScatterViewer(fig_s, fig_s.add_subplot(111), scatter_df, grid_bins=(grid_x_bins, grid_y_bins))
            self.mw.visualization_widgets[self.mw.group_scatter_tab] = viewer_s
            
            scatter_df['Grid_X_Index'] = pd.cut(scatter_df['Warped_X'], bins=calc_x_bins, labels=False, include_lowest=True)
            scatter_df['Grid_Y_Index'] = pd.cut(scatter_df['Warped_Y'], bins=calc_y_bins, labels=False, include_lowest=True)
            
            def circmean_phase(series):
                rad = (series / 12.0) * np.pi 
                mean_rad = circmean(rad, low=-np.pi, high=np.pi)
                return (mean_rad / np.pi) * 12.0
            
            group_binned = scatter_df.groupby(['Grid_X_Index', 'Grid_Y_Index'])['Relative_Phase_Hours'].apply(circmean_phase).reset_index()
            
            fig_g, _ = add_mpl_to_tab(self.mw.group_avg_tab)
            viewer_g = GroupAverageMapViewer(fig_g, fig_g.add_subplot(111), group_binned, scatter_df, (n_bins_x, n_bins_y), do_smooth)
            self.mw.visualization_widgets[self.mw.group_avg_tab] = viewer_g
            
            self.mw.vis_tabs.setTabEnabled(self.mw.vis_tabs.indexOf(self.mw.group_scatter_tab), True)
            self.mw.vis_tabs.setTabEnabled(self.mw.vis_tabs.indexOf(self.mw.group_avg_tab), True)
            
        except Exception as e:
            self.mw.log_message(f"Grid Visualization Error: {e}")

    def _generate_regional_stats(self, df):
        self.final_zone_stats = []
        min_cells = self.min_region_cells_spin.value()
        min_animals = self.min_animals_spin.value()
        unique_animals = df['Animal'].unique()
        
        self.mw.log_message("Calculating per-zone statistics...")

        for zid, z_info in self.zones.items():
            polys = z_info['polygons']
            zone_record = {'id': zid, 'name': z_info['name'], 'data': []}
            
            for animal in unique_animals:
                subset = df[df['Animal'] == animal]
                if subset.empty: continue
                
                points = subset[['X', 'Y']].values
                mask_in_zone = np.zeros(len(points), dtype=bool)
                for poly in polys:
                    mask_in_zone |= poly.contains_points(points)
                
                valid_phases = subset.loc[mask_in_zone, 'Rel_Phase'].values
                
                if len(valid_phases) >= min_cells:
                    rads = (valid_phases / 24.0) * (2 * np.pi)
                    m_rad = circmean(rads, low=-np.pi, high=np.pi)
                    m_val = (m_rad / (2 * np.pi)) * 24.0
                    
                    zone_record['data'].append({
                        'animal': animal,
                        'group': subset['Group'].iloc[0],
                        'mean': m_val,
                        'n_cells': len(valid_phases),
                        'raw_phases': valid_phases.tolist()
                    })

            ctrl_means = [d['mean'] for d in zone_record['data'] if d['group'] == 'Control']
            exp_means = [d['mean'] for d in zone_record['data'] if d['group'] == 'Experiment']
            
            zone_record['n_ctrl'] = len(ctrl_means)
            zone_record['n_exp'] = len(exp_means)
            
            if len(ctrl_means) >= min_animals and len(exp_means) >= min_animals:
                def group_circ(vals):
                    r = (np.array(vals) / 24.0) * (2*np.pi)
                    return (circmean(r) / (2*np.pi)) * 24.0

                zone_record['mean_ctrl'] = group_circ(ctrl_means)
                zone_record['mean_exp'] = group_circ(exp_means)
                
                f_val = watson_williams_f(ctrl_means, exp_means)
                df2 = len(ctrl_means) + len(exp_means) - 2
                p_val = 1.0 - f_dist.cdf(f_val, 1, df2)
                
                zone_record['p_value'] = p_val
                
                c_mean = zone_record['mean_ctrl']
                e_mean = zone_record['mean_exp']
                diff = (e_mean - c_mean + 12.0) % 24.0 - 12.0
                zone_record['diff_mean'] = diff
            else:
                zone_record['p_value'] = 1.0
                zone_record['diff_mean'] = 0.0

            self.final_zone_stats.append(zone_record)

        if not hasattr(self.mw, 'region_tab'):
            self.mw.region_tab = QtWidgets.QWidget()
            self.mw.vis_tabs.addTab(self.mw.region_tab, "Region Stats")
        
        # Handle layout safely to prevent console warnings
        layout = self.mw.region_tab.layout()
        if layout is None:
            layout = QtWidgets.QVBoxLayout(self.mw.region_tab)
        else:
            clear_layout(layout)
        
        viewer = RegionResultViewer(self.final_zone_stats, self.zones_polygons_map)
        self.mw.visualization_widgets[self.mw.region_tab] = viewer
        
        layout.addWidget(viewer)
        
        self.mw.vis_tabs.setTabEnabled(self.mw.vis_tabs.indexOf(self.mw.region_tab), True)
        self.mw.vis_tabs.setCurrentWidget(self.mw.region_tab)
        self.mw.log_message("Region Analysis Complete.")

    def _generate_gradient_analysis(self, df):
        atlas_path = self.state.atlas_roi_path
        if not atlas_path: return
        try:
            with open(atlas_path, 'r') as f: atlas_data = json.load(f)
            axis_rois = [r for r in atlas_data if r.get('mode') == 'Phase Axis']
            if not axis_rois: return
            
            self.mw.log_message(f"Running Gradient Analysis ({len(axis_rois)} Axes)...")
            axis_poly = np.array(axis_rois[0]['path_vertices'])
            
            gradient_data = []
            animals = df['Animal'].unique()
            
            for animal in animals:
                subset = df[df['Animal'] == animal]
                points = subset[['X', 'Y']].values
                phases = subset['Rel_Phase'].values
                group_name = subset['Group'].iloc[0]  # <--- Capture Group Name
                
                s_vals = project_points_to_polyline(points, axis_poly)
                bins = np.linspace(0, 1, 11)
                bin_centers = (bins[:-1] + bins[1:]) / 2
                binned_phases = []
                
                for k in range(len(bins)-1):
                    mask = (s_vals >= bins[k]) & (s_vals < bins[k+1])
                    if np.sum(mask) > 0:
                        p_bin = phases[mask]
                        rads = (p_bin / 24.0) * 2 * np.pi
                        m_rad = circmean(rads, low=-np.pi, high=np.pi)
                        m_h = (m_rad / (2 * np.pi)) * 24.0
                        binned_phases.append(m_h)
                    else:
                        binned_phases.append(np.nan)
                
                gradient_data.append({
                    'animal': animal,
                    'group': group_name, # <--- Pass Group Name
                    's': bin_centers,
                    'phases': np.array(binned_phases)
                })
                
            if not hasattr(self.mw, 'grad_tab'):
                self.mw.grad_tab = QtWidgets.QWidget()
                self.mw.vis_tabs.addTab(self.mw.grad_tab, "Gradient")
            
            # Use add_mpl_to_tab which manages the layout internally
            fig, _ = add_mpl_to_tab(self.mw.grad_tab)
            viewer_g = PhaseGradientViewer(fig, fig.add_subplot(111), gradient_data)
            self.mw.visualization_widgets[self.mw.grad_tab] = viewer_g
            
            self.mw.vis_tabs.setTabEnabled(self.mw.vis_tabs.indexOf(self.mw.grad_tab), True)

        except Exception as e:
            self.mw.log_message(f"Gradient Analysis Warning: {e}")

    def export_current_data(self):
        current_tab = self.mw.vis_tabs.currentWidget()
        if current_tab == getattr(self.mw, 'region_tab', None):
             viewer = current_tab.findChild(RegionResultViewer)
             if viewer:
                 df, fname = viewer.get_export_data()
                 path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Export", fname, "CSV (*.csv)")
                 if path:
                     df.to_csv(path, index=False)
                     self.mw.log_message(f"Saved to {path}")
                 return

        viewer = self.mw.visualization_widgets.get(current_tab)
        if viewer and hasattr(viewer, 'get_export_data'):
             df, fname = viewer.get_export_data()
             path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Export", fname, "CSV (*.csv)")
             if path:
                 df.to_csv(path, index=False)
                 self.mw.log_message(f"Saved to {path}")

================================================================
File: gui\panels\single_animal.py
================================================================
import os
import json
import numpy as np
import pandas as pd
from PyQt5 import QtWidgets, QtCore, QtGui
from matplotlib.path import Path
from scipy.stats import circmean

from gui.utils import Tooltip, clear_layout, add_mpl_to_tab
from gui.theme import get_icon
from gui.workers import AnalysisWorker, MovieLoaderWorker
from gui.dialogs.roi_drawer import ROIDrawerDialog
from gui.viewers import (
    HeatmapViewer,
    ContrastViewer,
    TrajectoryInspector,
    PhaseMapViewer,
    InterpolatedMapViewer,
)
from gui.analysis import (
    calculate_phases_fft,
    compute_median_window_frames,
    preprocess_for_rhythmicity,
    strict_cycle_mask,
    RHYTHM_TREND_WINDOW_HOURS,
)
import cosinor as csn

"""
SingleAnimalPanel invariants (do not change without intent and verification):

INDEXING / SELECTION
- "original_index" means the global candidate index in unfiltered space (0-based).
- "filtered_indices" maps local indices (in loaded_data) back to original_index.
- Viewers that display spatial points may show filtered data, but selection callbacks must
  ultimately resolve to original_index, then map to local_index via filtered_indices.

FILTER INTERSECTION
- The definitive filter is the intersection:
    final_mask = roi_mask & metric_mask
- roi_mask and metric_mask are always length == num_total_candidates (unfiltered space).
- The order of applying ROI vs Quality Gate must not change results, only the final intersection matters.

ROI SCHEMA
- ROI dictionaries may contain:
    {"mode": "Include"/"Exclude", "path_vertices": [...], optional "path": matplotlib.path.Path}
- Viewers must not assume "path" exists. Prefer path_vertices, build Path if needed.

PHASE REFERENCE
- phase_reference_rois are in the same coordinate space as state.unfiltered_data["roi"].
- Reference masking uses coordinates from loaded_data (post ROI/gate intersection), so any
  future coordinate transform must be applied consistently to both.
"""

class SingleAnimalPanel(QtWidgets.QWidget):
    def __init__(self, main_window):
        super().__init__(main_window)
        self.mw = main_window
        self.state = main_window.state
        
        # Local state
        self.params = {}
        self.phase_params = {}
        self.filtered_indices = None
        self.rois = None
        self.phase_reference_rois = None
        self.vmin = None
        self.vmax = None
        self.metrics_df = None
        self.latest_rhythm_df = None
        
        # Filtering State
        self.roi_mask = None
        self.metric_mask = None
        self.num_total_candidates = 0
        self.quality_presets = {}  # Computed on load
        
        # Thread handles
        self._analysis_worker = None
        self._analysis_thread = None
        self._movie_loader_worker = None
        self._movie_loader_thread = None

        # Visibility Tracking
        self.advanced_widgets = [] # List of widgets to hide/show

        self.init_ui()
        
        # --- Legacy label aliases (MainWindow expects these attribute names) ---
        # Keep these as direct references to the new workflow strip labels so
        # MainWindow.update_workflow_from_files() continues to work unchanged.
        self.status_input_label = self.lbl_status_input
        self.status_traces_label = self.lbl_status_results
        self.status_mode_label = self.lbl_status_mode
        self.status_gate_label = self.lbl_status_gate
        self.status_roi_label = self.lbl_status_roi
                
        # Some older MainWindow code also expects these:
        # We do not have separate strip slots for each file type in the rewrite,
        # so map them to "Results"
        self.status_traj_label = self.lbl_status_results
        self.status_metrics_label = self.lbl_status_mode  # metrics implies scored/strict mode
        self.status_roi_file_label = self.lbl_status_roi  # ROI file presence, treated as ROI status
          
        self.connect_signals()
        
        # Initial State
        self._set_ui_mode(False) # Default to Basic
        self._update_workflow_status()

    def init_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        
        # --- Top Control Bar ---
        top_row = QtWidgets.QHBoxLayout()
        self.chk_advanced_mode = QtWidgets.QCheckBox("Show Advanced Controls")
        top_row.addWidget(self.chk_advanced_mode)
        top_row.addStretch(1)
        layout.addLayout(top_row)

        # --- 1. File I/O Box ---
        self.io_box = QtWidgets.QGroupBox("File I/O")
        io_layout = QtWidgets.QGridLayout(self.io_box)
        
        self.btn_load_movie = QtWidgets.QPushButton(get_icon('fa5s.file-video'), "Load Movie...")
        io_layout.addWidget(self.btn_load_movie, 0, 0, 1, 2)
        
        io_layout.addWidget(QtWidgets.QLabel("Input File:"), 1, 0)
        self.input_file_edit = QtWidgets.QLineEdit()
        self.input_file_edit.setReadOnly(True)
        io_layout.addWidget(self.input_file_edit, 1, 1)
        
        io_layout.addWidget(QtWidgets.QLabel("Output Basename:"), 2, 0)
        self.output_base_edit = QtWidgets.QLineEdit()
        io_layout.addWidget(self.output_base_edit, 2, 1)
        
        layout.addWidget(self.io_box)

        # --- 2. Workflow Status Strip ---
        self.workflow_box = QtWidgets.QGroupBox("Workflow Status")
        wf_layout = QtWidgets.QHBoxLayout(self.workflow_box)
        
        self.lbl_status_input = QtWidgets.QLabel("Input: none")
        self.lbl_status_results = QtWidgets.QLabel("Results: none")
        self.lbl_status_mode = QtWidgets.QLabel("Mode: unknown")
        self.lbl_status_gate = QtWidgets.QLabel("Gate: off")
        self.lbl_status_roi = QtWidgets.QLabel("ROI: off")
        
        for lbl in [self.lbl_status_input, self.lbl_status_results, self.lbl_status_mode, self.lbl_status_gate, self.lbl_status_roi]:
            lbl.setStyleSheet("font-size: 11px; color: #333; padding: 2px; border: 1px solid #ccc; border-radius: 3px; background: #f9f9f9;")
            wf_layout.addWidget(lbl)
            
        layout.addWidget(self.workflow_box)

        # --- 3. ROI Box ---
        self.roi_box = QtWidgets.QGroupBox("Region of Interest (ROI)")
        roi_layout = QtWidgets.QHBoxLayout(self.roi_box)
        self.btn_define_roi = QtWidgets.QPushButton(get_icon('fa5s.pen'), "Define Anatomical ROI...")
        self.btn_define_roi.setEnabled(False)
        Tooltip.install(self.btn_define_roi, "Draw include/exclude polygons to filter cells spatially.")
        
        self.btn_clear_roi = QtWidgets.QPushButton(get_icon('fa5s.times'), "Clear ROI Filter")
        self.btn_clear_roi.setEnabled(False)
        
        roi_layout.addWidget(self.btn_define_roi)
        roi_layout.addWidget(self.btn_clear_roi)
        layout.addWidget(self.roi_box)
        
        # --- 4. Quality Gate Box (Replaces Post-Hoc Filtering) ---
        self.quality_gate_box = QtWidgets.QGroupBox("Quality Gate")
        gate_layout = QtWidgets.QGridLayout(self.quality_gate_box)
        
        # Row 0: Presets & Override
        gate_layout.addWidget(QtWidgets.QLabel("Preset:"), 0, 0)
        self.quality_preset_combo = QtWidgets.QComboBox()
        self.quality_preset_combo.addItems(["Recommended", "Lenient", "Strict", "Manual"])
        gate_layout.addWidget(self.quality_preset_combo, 0, 1)
        
        self.chk_quality_manual_override = QtWidgets.QCheckBox("Manual Override")
        gate_layout.addWidget(self.chk_quality_manual_override, 0, 2)
        
        # Row 1: Manual Controls (Hidden by default unless override)
        self.manual_gate_widget = QtWidgets.QWidget()
        manual_layout = QtWidgets.QHBoxLayout(self.manual_gate_widget)
        manual_layout.setContentsMargins(0, 0, 0, 0)
        
        self.spin_coverage = QtWidgets.QDoubleSpinBox()
        self.spin_coverage.setRange(0.0, 1.0); self.spin_coverage.setSingleStep(0.05)
        self.spin_coverage.setPrefix("Cov >= ")
        manual_layout.addWidget(self.spin_coverage)
        
        self.spin_jitter = QtWidgets.QDoubleSpinBox()
        self.spin_jitter.setRange(0.0, 50.0); self.spin_jitter.setSingleStep(0.5)
        self.spin_jitter.setPrefix("Jit <= ")
        manual_layout.addWidget(self.spin_jitter)
        
        self.spin_snr = QtWidgets.QDoubleSpinBox()
        self.spin_snr.setRange(0.0, 50.0); self.spin_snr.setSingleStep(0.5)
        self.spin_snr.setPrefix("SNR >= ")
        manual_layout.addWidget(self.spin_snr)
        
        gate_layout.addWidget(self.manual_gate_widget, 1, 0, 1, 3)
        self.manual_gate_widget.setVisible(False) # Initial state
        
        # Row 2: Apply & Status
        self.btn_apply_quality_gate = QtWidgets.QPushButton(get_icon('fa5s.filter'), "Apply Quality Gate")
        gate_layout.addWidget(self.btn_apply_quality_gate, 2, 0, 1, 1)
        
        self.lbl_quality_counts = QtWidgets.QLabel("Passing: - / -")
        self.lbl_quality_counts.setAlignment(QtCore.Qt.AlignCenter)
        self.lbl_quality_counts.setStyleSheet("font-weight: bold;")
        gate_layout.addWidget(self.lbl_quality_counts, 2, 1, 1, 2)
        
        self.lbl_quality_breakdown = QtWidgets.QLabel("")
        self.lbl_quality_breakdown.setStyleSheet("color: gray; font-size: 10px;")
        gate_layout.addWidget(self.lbl_quality_breakdown, 3, 0, 1, 3)
        
        layout.addWidget(self.quality_gate_box)

        # --- 5. Analysis Parameters (Advanced Only) ---
        self.param_box = QtWidgets.QGroupBox("Analysis Parameters")
        param_layout = QtWidgets.QVBoxLayout(self.param_box)
        
        # Save/Load
        btn_row = QtWidgets.QHBoxLayout()
        self.btn_save_params = QtWidgets.QPushButton(get_icon('fa5s.download'), "Save Params...")
        self.btn_load_params = QtWidgets.QPushButton(get_icon('fa5s.upload'), "Load Params...")
        btn_row.addWidget(self.btn_save_params)
        btn_row.addWidget(self.btn_load_params)
        param_layout.addLayout(btn_row)
        
        # Tabs
        self.param_tabs = QtWidgets.QTabWidget()
        param_layout.addWidget(self.param_tabs)
        
        # Define Tooltips
        param_tooltips = {
            "sigma1": "Smaller Gaussian blur radius (pixels).",
            "sigma2": "Larger Gaussian blur radius (pixels) for background subtraction.",
            "blur_sigma": "Blur applied before ranking features.",
            "max_features": "Max brightest features per frame.",
            "search_range": "Max frames to look backward for linking.",
            "cone_radius_base": "Initial search radius (pixels).",
            "cone_radius_multiplier": "Radius growth factor per frame gap.",
            "min_trajectory_length": "Min track length (fraction of movie).",
            "sampling_box_size": "Intensity sampling box size (pixels).",
            "sampling_sigma": "Gaussian weights sigma for sampling.",
            "max_interpolation_distance": "Max allowed jump (pixels) between frames."
        }

        # Populate Tabs
        det_tab = QtWidgets.QWidget()
        det_layout = QtWidgets.QFormLayout(det_tab)
        self._add_param_field(det_layout, "sigma1", 3.0, param_tooltips)
        self._add_param_field(det_layout, "sigma2", 20.0, param_tooltips)
        self._add_param_field(det_layout, "blur_sigma", 2.0, param_tooltips)
        self._add_param_field(det_layout, "max_features", 200, param_tooltips)
        self.param_tabs.addTab(det_tab, "Detection")
        
        tr_tab = QtWidgets.QWidget()
        tr_layout = QtWidgets.QFormLayout(tr_tab)
        self._add_param_field(tr_layout, "search_range", 50, param_tooltips)
        self._add_param_field(tr_layout, "cone_radius_base", 1.5, param_tooltips)
        self._add_param_field(tr_layout, "cone_radius_multiplier", 0.125, param_tooltips)
        self.param_tabs.addTab(tr_tab, "Tracking")
        
        fl_tab = QtWidgets.QWidget()
        fl_layout = QtWidgets.QFormLayout(fl_tab)
        self._add_param_field(fl_layout, "min_trajectory_length", 0.08, param_tooltips)
        self._add_param_field(fl_layout, "sampling_box_size", 15, param_tooltips)
        self._add_param_field(fl_layout, "sampling_sigma", 2.0, param_tooltips)
        self._add_param_field(fl_layout, "max_interpolation_distance", 5.0, param_tooltips)
        
        self.mode_combo = QtWidgets.QComboBox()
        self.mode_combo.addItem("Legacy pipeline (no metrics)", "strict")
        self.mode_combo.addItem("Metrics pipeline (recommended)", "scored")
        Tooltip.install(
            self.mode_combo,
            "This controls the analysis pipeline run by AnalysisWorker. "
            "Separately, the Quality Gate is available only if a valid metrics CSV is loaded."
        )
        
        # Default to scored pipeline so users get full candidate set, then gate post hoc.
        idx = self.mode_combo.findData("scored")
        if idx >= 0:
            self.mode_combo.setCurrentIndex(idx)
        
        fl_layout.addRow("Analysis Pipeline:", self.mode_combo)
        
        self.param_tabs.addTab(fl_tab, "Filtering")
        
        layout.addWidget(self.param_box)
        self.advanced_widgets.append(self.param_box) # Whole box is advanced

        # --- 6. Phase Map Parameters ---
        self.phase_box = QtWidgets.QGroupBox("Phase Map Parameters")
        phase_layout = QtWidgets.QFormLayout(self.phase_box)
        
        # Basic Phase Controls
        self.analysis_method_combo = QtWidgets.QComboBox()
        self.analysis_method_combo.addItems(["FFT (SNR)", "Cosinor (p-value)"])
        phase_layout.addRow("Analysis Method:", self.analysis_method_combo)
        
        self._add_phase_field(phase_layout, "minutes_per_frame", 15.0)
        
        self.discovered_period_edit = QtWidgets.QLineEdit("N/A")
        self.discovered_period_edit.setReadOnly(True)
        phase_layout.addRow("Discovered Period (hrs):", self.discovered_period_edit)
        
        _, self.rhythm_threshold_label = self._add_phase_field(phase_layout, "rhythm_threshold", 2.0)
        
        # Cosinor specific (Conditional)
        self.rsquared_le, self.rsquared_label = self._add_phase_field(phase_layout, "r_squared_threshold", 0.3)
        self.rsquared_widgets = [self.rsquared_le, self.rsquared_label]
        
        self.strict_cycle_check = QtWidgets.QCheckBox("Require >= 2 cycles")
        phase_layout.addRow(self.strict_cycle_check)
        
        self.emphasize_rhythm_check = QtWidgets.QCheckBox("Emphasize rhythmic cells")
        phase_layout.addRow(self.emphasize_rhythm_check)
        
        # Advanced Phase Controls (Collected for toggling)
        self.adv_phase_rows = []
        
        self.adv_phase_rows.extend(self._add_phase_field(phase_layout, "period_min", 22.0, is_advanced=True))
        self.adv_phase_rows.extend(self._add_phase_field(phase_layout, "period_max", 28.0, is_advanced=True))
        self.adv_phase_rows.extend(self._add_phase_field(phase_layout, "trend_window_hours", 36.0, is_advanced=True))
        self.adv_phase_rows.extend(self._add_phase_field(phase_layout, "grid_resolution", 100, int, is_advanced=True))
        
        self.use_subregion_ref_check = QtWidgets.QCheckBox("Set phase zero using reference polygon")
        self.use_subregion_ref_check.setEnabled(False)
        phase_layout.addRow(self.use_subregion_ref_check)
        self.adv_phase_rows.append(self.use_subregion_ref_check)
        
        # Actions (Always visible)
        btn_row = QtWidgets.QHBoxLayout()
        self.btn_regen_phase = QtWidgets.QPushButton(get_icon('fa5s.sync'), "Update Plots")
        self.btn_save_rhythm = QtWidgets.QPushButton(get_icon('fa5s.save'), "Save Rhythm Results")
        self.btn_save_rhythm.setEnabled(False)
        btn_row.addWidget(self.btn_regen_phase)
        btn_row.addWidget(self.btn_save_rhythm)
        phase_layout.addRow(btn_row)
        
        layout.addWidget(self.phase_box)
        layout.addStretch(1)
        
        # Init dynamic UI state
        self._on_analysis_method_changed(0)

    def _add_param_field(self, layout, name, default, tooltips=None):
        label = QtWidgets.QLabel(f"{name}:")
        if tooltips and name in tooltips:
            Tooltip.install(label, tooltips[name])
        le = QtWidgets.QLineEdit(str(default))
        layout.addRow(label, le)
        self.params[name] = (le, type(default))
        return le, label

    def _add_phase_field(self, layout, name, default, typ=float, is_advanced=False):
        label = QtWidgets.QLabel(f"{name}:")
        le = QtWidgets.QLineEdit(str(default))
        layout.addRow(label, le)
        self.phase_params[name] = (le, typ)
        if is_advanced:
            self.advanced_widgets.append(label)
            self.advanced_widgets.append(le)
            return [label, le]
        return [le, label]

    def connect_signals(self):
        # Top Level
        self.chk_advanced_mode.toggled.connect(self._set_ui_mode)
        
        # IO
        self.btn_load_movie.clicked.connect(self.load_movie)
        self.output_base_edit.textChanged.connect(self.update_output_basename)
        
        # ROI
        self.btn_define_roi.clicked.connect(self.open_roi_tool)
        self.btn_clear_roi.clicked.connect(self.clear_roi_filter)
        
        # Quality Gate
        self.quality_preset_combo.currentIndexChanged.connect(self._on_preset_changed)
        self.chk_quality_manual_override.toggled.connect(self._on_manual_override_toggled)
        self.btn_apply_quality_gate.clicked.connect(self.apply_quality_gate)
        
        # Params
        self.btn_save_params.clicked.connect(self.save_parameters)
        self.btn_load_params.clicked.connect(self.load_parameters)
        
        # Main Window Hooks
        self.mw.btn_run_analysis.clicked.connect(self.start_analysis)
        self.mw.btn_load_results.clicked.connect(self.load_results)
        self.mw.btn_export_plot.clicked.connect(self.export_current_plot)
        self.mw.btn_export_data.clicked.connect(self.export_current_data)
        
        # Phase
        self.btn_regen_phase.clicked.connect(self.regenerate_phase_maps)
        self.btn_save_rhythm.clicked.connect(self.save_rhythm_results)
        self.emphasize_rhythm_check.stateChanged.connect(self.regenerate_phase_maps)
        self.use_subregion_ref_check.stateChanged.connect(self.regenerate_phase_maps)
        self.analysis_method_combo.currentIndexChanged.connect(self._on_analysis_method_changed)

    # --- UI Controller Logic ---
    
    def _set_ui_mode(self, is_advanced):
        for widget in self.advanced_widgets:
            widget.setVisible(is_advanced)
        # Handle specialized advanced rows list
        for widget in self.adv_phase_rows:
            widget.setVisible(is_advanced)
            
    def _update_workflow_status(self):
        # 1. Input
        if self.state.input_movie_path:
            self.lbl_status_input.setText(f"Input: {os.path.basename(self.state.input_movie_path)}")
            self.lbl_status_input.setStyleSheet("background: #d4edda; border: 1px solid #c3e6cb;")
        else:
            self.lbl_status_input.setText("Input: none")
            self.lbl_status_input.setStyleSheet("background: #f9f9f9; border: 1px solid #ccc;")

        # 2. Results
        has_traces = self.state.unfiltered_data.get("traces") is not None
        if has_traces:
            self.lbl_status_results.setText("Results: loaded")
            self.lbl_status_results.setStyleSheet("background: #d4edda; border: 1px solid #c3e6cb;")
        else:
            self.lbl_status_results.setText("Results: none")
            self.lbl_status_results.setStyleSheet("background: #f9f9f9; border: 1px solid #ccc;")
            
        # 3. Mode (Determined by metrics availability)
        has_metrics = self.metrics_df is not None
        if has_traces:
            if has_metrics:
                self.lbl_status_mode.setText("Metrics: available")
                self.lbl_status_mode.setStyleSheet("background: #cce5ff; border: 1px solid #b8daff;")
            else:
                self.lbl_status_mode.setText("Metrics: missing")
                self.lbl_status_mode.setStyleSheet("background: #fff3cd; border: 1px solid #ffeeba;")
        else:
            self.lbl_status_mode.setText("Mode: ")
            self.lbl_status_mode.setStyleSheet("background: #f9f9f9;")

        # 4. ROI
        N = self.num_total_candidates
        roi_n = self.roi_mask.sum() if self.roi_mask is not None else 0
        if self.roi_mask is not None and roi_n < N:
             self.lbl_status_roi.setText(f"ROI: Active ({roi_n})")
             self.lbl_status_roi.setStyleSheet("background: #d4edda; border: 1px solid #c3e6cb;")
        else:
             self.lbl_status_roi.setText("ROI: Off")
             self.lbl_status_roi.setStyleSheet("background: #f9f9f9; border: 1px solid #ccc;")

        # 5. Gate
        gate_n = self.metric_mask.sum() if self.metric_mask is not None else 0
        if self.metric_mask is not None and gate_n < N:
            method = "Manual" if self.chk_quality_manual_override.isChecked() else self.quality_preset_combo.currentText()
            self.lbl_status_gate.setText(f"Gate: {method} ({gate_n})")
            self.lbl_status_gate.setStyleSheet("background: #d4edda; border: 1px solid #c3e6cb;")
        else:
            self.lbl_status_gate.setText("Gate: Off")
            self.lbl_status_gate.setStyleSheet("background: #f9f9f9; border: 1px solid #ccc;")
            
        # 6. Overall Counts
        final_n = (self.roi_mask & self.metric_mask).sum() if (self.roi_mask is not None and self.metric_mask is not None) else 0
        if N > 0:
            pct = (final_n / N) * 100.0
            self.lbl_quality_counts.setText(f"Passing: {final_n} / {N} ({pct:.1f}%)")
        else:
            self.lbl_quality_counts.setText("Passing: - / -")

    def _on_preset_changed(self):
        # Do not apply immediately. Just update UI spinboxes if we are in a mode that allows it.
        # This gives visual feedback of what "Strict" actually means in numbers.
        preset_name = self.quality_preset_combo.currentText()
        if preset_name == "Manual":
            self.chk_quality_manual_override.setChecked(True)
            return

        vals = self.quality_presets.get(preset_name)
        if vals:
            self.spin_coverage.setValue(vals.get('cov', 0.0))
            self.spin_jitter.setValue(vals.get('jit', 50.0))
            self.spin_snr.setValue(vals.get('snr', 0.0))

    def _on_manual_override_toggled(self, checked):
        self.manual_gate_widget.setVisible(checked)
        if checked:
            self.quality_preset_combo.setCurrentText("Manual")

    def _compute_quality_presets(self):
        """Derive preset thresholds dynamically from loaded metrics percentiles."""
        if self.metrics_df is None: 
            self.quality_presets = {}
            return

        df = self.metrics_df
        presets = {}
        
        # Helper to get percentile or default
        def get_p(col, p, default, reverse=False):
            if col not in df.columns: return default
            vals = pd.to_numeric(df[col], errors='coerce').values
            vals = vals[np.isfinite(vals)]
            if len(vals) == 0: return default
            return np.percentile(vals, p)

        # 1. Lenient (Bottom 50% cov, Top 95% jitter, Top 90% SNR)
        presets["Lenient"] = {
            'cov': get_p('detected_fraction', 50, 0.0),
            'jit': get_p('spatial_jitter_detrended', 95, 50.0),
            'snr': get_p('trace_snr_proxy', 10, 0.0)
        }
        
        # 2. Recommended (Top 75% cov, Bottom 75% jitter, Top 25% SNR)
        presets["Recommended"] = {
            'cov': get_p('detected_fraction', 75, 0.5),
            'jit': get_p('spatial_jitter_detrended', 75, 5.0),
            'snr': get_p('trace_snr_proxy', 25, 2.0)
        }
        
        # 3. Strict (Top 90% cov, Bottom 50% jitter, Top 50% SNR)
        presets["Strict"] = {
            'cov': get_p('detected_fraction', 90, 0.8),
            'jit': get_p('spatial_jitter_detrended', 50, 2.0),
            'snr': get_p('trace_snr_proxy', 50, 5.0)
        }
        
        self.quality_presets = presets
        # Update spinboxes to Recommended by default without applying
        if "Recommended" in presets:
            self.spin_coverage.setValue(presets["Recommended"]['cov'])
            self.spin_jitter.setValue(presets["Recommended"]['jit'])
            self.spin_snr.setValue(presets["Recommended"]['snr'])

    # --- Data Loading & Analysis ---

    def reset_state(self):
        """
        Called by MainWindow._reset_state().

        This must exist even if we do most state clearing in MainWindow,
        because older workflow assumes each panel can reset itself safely.
        """
        # Local state (panel)
        self.filtered_indices = None
        self.rois = None
        self.phase_reference_rois = None
        self.vmin = None
        self.vmax = None
        self.metrics_df = None
        self.latest_rhythm_df = None

        # Masks and counts
        self.roi_mask = None
        self.metric_mask = None
        self.num_total_candidates = 0
        self.quality_presets = {}

        # UI: disable things that require loaded data
        if hasattr(self, "input_file_edit"):
            self.input_file_edit.setText("")
        if hasattr(self, "output_base_edit"):
            self.output_base_edit.setText("")

        if hasattr(self, "btn_define_roi"):
            self.btn_define_roi.setEnabled(False)
        if hasattr(self, "btn_clear_roi"):
            self.btn_clear_roi.setEnabled(False)

        # Quality gate: default to disabled until metrics load
        if hasattr(self, "quality_gate_box"):
            self.quality_gate_box.setEnabled(False)
            self.quality_gate_box.setTitle("Quality Gate (Unavailable - No Metrics)")
        if hasattr(self, "lbl_quality_counts"):
            self.lbl_quality_counts.setText("Passing: - / -")
        if hasattr(self, "lbl_quality_breakdown"):
            self.lbl_quality_breakdown.setText("")

        # Phase controls that depend on ROI refs
        if hasattr(self, "use_subregion_ref_check"):
            self.use_subregion_ref_check.setChecked(False)
            self.use_subregion_ref_check.setEnabled(False)

        if hasattr(self, "btn_save_rhythm"):
            self.btn_save_rhythm.setEnabled(False)

        # Clear visualization tabs safely if they exist
        try:
            for tab in (self.mw.heatmap_tab, self.mw.com_tab, self.mw.traj_tab, self.mw.phase_tab, self.mw.interp_tab):
                if tab.layout() is not None:
                    clear_layout(tab.layout())
        except Exception:
            pass

        self._update_workflow_status()

    def load_movie(self):
        self.mw._reset_state()
        start_dir = self.mw._get_last_dir()
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Select Movie", start_dir, "TIFF files (*.tif *.tiff);;All files (*.*)"
        )
        if not path: return
        
        self.mw._set_last_dir(path)
        self.state.input_movie_path = path
        self.input_file_edit.setText(path)
        base, _ = os.path.splitext(path)
        self.state.output_basename = base
        self.output_base_edit.setText(base)
        self.mw.workflow_state["has_input"] = True
        self.mw.log_message(f"Loaded movie: {os.path.basename(path)}")
        self.mw.update_workflow_from_files()
        self._update_workflow_status()

    def update_output_basename(self, text):
        self.state.output_basename = text
        self.mw.update_workflow_from_files()

    def start_analysis(self):
        if not self.state.input_movie_path or not self.state.output_basename:
            self.mw.log_message("Error: input file and output basename required.")
            return
        try:
            args = {name: t(le.text()) for name, (le, t) in self.params.items()}
            mode = self.mode_combo.currentData()
            args['mode'] = mode if mode else 'strict'
        except ValueError as e:
            self.mw.log_message(f"Error in analysis parameters: {e}")
            return
        
        self.mw.log_text.clear()
        self.mw.progress_bar.setValue(0)
        self.mw.btn_run_analysis.setEnabled(False)
        self.mw.btn_load_results.setEnabled(False)
        self._analysis_worker = AnalysisWorker(self.state.input_movie_path, self.state.output_basename, args)
        self._analysis_thread = QtCore.QThread(self)
        self._analysis_worker.moveToThread(self._analysis_thread)
        self._analysis_thread.started.connect(self._analysis_worker.run)
        self._analysis_worker.message.connect(self.mw.log_message)
        self._analysis_worker.progress.connect(lambda v: self.mw.progress_bar.setValue(int(v * 100)))
        
        def done(success, msg):
            self._analysis_thread.quit()
            self._analysis_thread.wait()
            self._analysis_worker = None
            self._analysis_thread = None
            import gc; gc.collect()

            if success:
                self.mw.log_message("Analysis finished. Loading results...")
                self.load_results()
            else:
                self.mw.log_message("Analysis failed.")
            self.mw.update_workflow_from_files()
            self._update_workflow_status()
            
        self._analysis_worker.finished.connect(done)
        self._analysis_thread.start()

    def load_results(self):
        basename = self.state.output_basename
        if not basename:
            self.mw.log_message("Error: Output basename not set.")
            return

        if self._movie_loader_thread is not None and self._movie_loader_thread.isRunning():
            self.mw.log_message("Movie is already being loaded.")
            return

        try:
            # Load basic data
            traces = np.loadtxt(f"{basename}_traces.csv", delimiter=",")
            roi = np.loadtxt(f"{basename}_roi.csv", delimiter=",")
            traj = np.load(f"{basename}_trajectories.npy")

            if isinstance(roi, np.ndarray) and roi.ndim == 1: roi = roi.reshape(1, -1)
            if isinstance(traces, np.ndarray) and traces.ndim == 1: traces = traces.reshape(1, -1)

            self.state.unfiltered_data["traces"] = traces
            self.state.unfiltered_data["roi"] = roi
            self.state.unfiltered_data["trajectories"] = traj
            
            # Reset masks
            self.num_total_candidates = len(roi)
            self.roi_mask = np.ones(self.num_total_candidates, dtype=bool)
            self.metric_mask = np.ones(self.num_total_candidates, dtype=bool)
            
            # Load Metrics
            metrics_path = f"{basename}_metrics.csv"
            has_metrics = False
            
            if os.path.exists(metrics_path):
                df = pd.read_csv(metrics_path)
                if "candidate_id" in df.columns:
                    df = df.sort_values("candidate_id").reset_index(drop=True)
                    if len(df) == self.num_total_candidates:
                        self.metrics_df = df
                        has_metrics = True
                        self._compute_quality_presets()
                        self.mw.log_message(f"Metrics loaded: {len(df)} rows. Scored mode active.")
            
            if not has_metrics:
                self.metrics_df = None
                
                # Metrics missing, force strict mode to match what the pipeline can support.
                idx = self.mode_combo.findData("strict")
                if idx >= 0:
                    self.mode_combo.setCurrentIndex(idx)
                
                self.quality_gate_box.setEnabled(False)
                self.quality_gate_box.setTitle("Quality Gate (Unavailable - No Metrics)")
                self.mw.log_message("No valid metrics found. Strict mode active (manual ROI only).")
            else:
                self.quality_gate_box.setEnabled(True)
                self.quality_gate_box.setTitle("Quality Gate")
                self.quality_preset_combo.setCurrentText("Recommended")
                # Metrics present, scored mode is valid and should be the default.
                idx = self.mode_combo.findData("scored")
                if idx >= 0:
                    self.mode_combo.setCurrentIndex(idx)

            self.mw.log_message("Loaded ROI and trace data.")
            self._update_workflow_status()
            
        except Exception as e:
            self.mw.log_message(f"Error loading result files: {e}")
            return

        self.btn_load_movie.setEnabled(False)
        self.mw.btn_load_results.setEnabled(False)
        self.mw.log_message("Loading movie in background...")

        self._movie_loader_worker = MovieLoaderWorker(self.state.input_movie_path)
        self._movie_loader_thread = QtCore.QThread(self)
        self._movie_loader_worker.moveToThread(self._movie_loader_thread)

        self._movie_loader_thread.started.connect(self._movie_loader_worker.run)
        self._movie_loader_worker.finished.connect(self._on_movie_loaded)
        self._movie_loader_worker.error.connect(self._on_movie_load_error)

        self._movie_loader_worker.finished.connect(self._movie_loader_thread.quit)
        self._movie_loader_thread.finished.connect(self._movie_loader_thread.deleteLater)
        self._movie_loader_worker.finished.connect(self._movie_loader_worker.deleteLater)

        self._movie_loader_thread.start()

    @QtCore.pyqtSlot(object)
    def _on_movie_loaded(self, movie_data):
        self.mw.log_message("Movie loaded.")
        self.state.unfiltered_data["movie"] = movie_data
        self.state.unfiltered_data["background"] = movie_data[len(movie_data) // 2]
        
        self.btn_load_movie.setEnabled(True)
        self.mw.btn_load_results.setEnabled(True)
        
        # Enable ROI tool if results are present
        self.btn_define_roi.setEnabled(True)
        
        self._resolve_filters()
        self._movie_loader_thread = None
        self._movie_loader_worker = None

    @QtCore.pyqtSlot(str)
    def _on_movie_load_error(self, error_message):
        self.mw.log_message(f"Movie load failed: {error_message}")
        self.btn_load_movie.setEnabled(True)
        self.mw.btn_load_results.setEnabled(True)
        if self._movie_loader_thread:
            self._movie_loader_thread.quit()
            self._movie_loader_thread.wait()
        self._movie_loader_thread = None
        self._movie_loader_worker = None

    # --- Filtering Logic ---

    def apply_post_hoc_filters(self):
        """Compatibility wrapper for apply_quality_gate."""
        self.apply_quality_gate()

    def apply_quality_gate(self):
        if self.metrics_df is None: return
        
        use_manual = self.chk_quality_manual_override.isChecked()
        preset_name = self.quality_preset_combo.currentText()
        
        # Determine thresholds
        if use_manual or preset_name == "Manual":
            cov_min = self.spin_coverage.value()
            jit_max = self.spin_jitter.value()
            snr_min = self.spin_snr.value()
        else:
            vals = self.quality_presets.get(preset_name, {})
            cov_min = vals.get('cov', 0.0)
            jit_max = vals.get('jit', 50.0)
            snr_min = vals.get('snr', 0.0)
            
        # Get data columns (safe fallback)
        df = self.metrics_df
        def get_col(name):
             if name in df.columns: return pd.to_numeric(df[name], errors='coerce').to_numpy(dtype=float)
             return np.full(len(df), np.nan) # Fail closed if column missing? No, logic below handles NaN.

        cov = get_col('detected_fraction')
        jit = get_col('spatial_jitter_detrended')
        snr = get_col('trace_snr_proxy')

        # Compute Masks (handling NaNs as Fail)
        cov_ok = np.isfinite(cov) & (cov >= cov_min)
        jit_ok = np.isfinite(jit) & (jit <= jit_max)
        snr_ok = np.isfinite(snr) & (snr >= snr_min)
        
        self.metric_mask = cov_ok & jit_ok & snr_ok
        
        # Update breakdown label
        n_fail_cov = (~cov_ok).sum()
        n_fail_jit = (~jit_ok).sum()
        n_fail_snr = (~snr_ok).sum()
        self.lbl_quality_breakdown.setText(f"Failures: Cov={n_fail_cov}, Jit={n_fail_jit}, SNR={n_fail_snr}")
        
        self._resolve_filters()

    def open_roi_tool(self):
        if "background" not in self.state.unfiltered_data:
            self.mw.log_message("Error: Load data before defining an ROI.")
            return
        if not self.state.output_basename:
            self.mw.log_message("Error: Output Basename required.")
            return
        dlg = ROIDrawerDialog(
            self,
            self.state.unfiltered_data["background"],
            self.state.unfiltered_data["roi"],
            self.state.output_basename,
            self.apply_roi_filter,
            vmin=self.vmin,
            vmax=self.vmax,
        )
        dlg.exec_()
        self.mw.update_workflow_from_files()

    def apply_roi_filter(self, indices, rois, phase_ref_rois, extra_mask=None):
        self.rois = rois
        self.phase_reference_rois = phase_ref_rois
        self.use_subregion_ref_check.setEnabled(bool(phase_ref_rois))
        if not phase_ref_rois: 
            self.use_subregion_ref_check.setChecked(False)

        if not rois:
            self.roi_mask = np.ones(self.num_total_candidates, dtype=bool)
        else:
            full_roi_data = self.state.unfiltered_data["roi"]
            mask = np.zeros(self.num_total_candidates, dtype=bool)
            
            # Robust Include
            has_includes = False
            for r in rois:
                if r.get("mode", "").lower() == "include":
                    if "path_vertices" in r:
                        path = Path(r["path_vertices"])
                        mask |= path.contains_points(full_roi_data)
                        has_includes = True
            
            # If no includes defined but excludes exist, start with ALL TRUE
            if not has_includes:
                mask[:] = True
                
            # Exclude
            for r in rois:
                if r.get("mode", "").lower() == "exclude":
                    if "path_vertices" in r:
                        path = Path(r["path_vertices"])
                        mask &= ~path.contains_points(full_roi_data)
                        
            self.roi_mask = mask
            
        self._resolve_filters()

    def clear_roi_filter(self):
        self.rois = None
        self.phase_reference_rois = None
        self.use_subregion_ref_check.setChecked(False)
        self.use_subregion_ref_check.setEnabled(False)
        self.roi_mask = np.ones(self.num_total_candidates, dtype=bool)
        self._resolve_filters()

    def _resolve_filters(self):
        if self.roi_mask is None: self.roi_mask = np.ones(self.num_total_candidates, dtype=bool)
        if self.metric_mask is None: self.metric_mask = np.ones(self.num_total_candidates, dtype=bool)
        
        final_mask = self.roi_mask & self.metric_mask
        final_indices = np.where(final_mask)[0]
        
        self.filtered_indices = final_indices
        self._update_workflow_status()
        
        # Check State Consistency
        is_filtered = len(final_indices) < self.num_total_candidates
        
        if not is_filtered:
             self.state.loaded_data = dict(self.state.unfiltered_data)
             self.btn_clear_roi.setEnabled(False)
        else:
             self.state.loaded_data = {} # Clear/Init
             self.state.loaded_data["roi"] = self.state.unfiltered_data["roi"][final_indices]
             self.state.loaded_data["trajectories"] = self.state.unfiltered_data["trajectories"][final_indices]
             trace_indices = np.concatenate(([0], final_indices + 1))
             self.state.loaded_data["traces"] = self.state.unfiltered_data["traces"][:, trace_indices]
             self.btn_clear_roi.setEnabled(True)

        self.populate_visualizations()

    # --- Parameter IO ---

    def save_parameters(self):
        start_dir = self.mw._get_last_dir()
        path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, "Save Parameters", start_dir, "JSON files (*.json)"
        )
        if not path: return
        self.mw._set_last_dir(path)
        data = {name: le.text() for name, (le, _) in self.params.items()}
        mode = self.mode_combo.currentData()
        if mode: data['mode'] = mode
        with open(path, "w") as f: json.dump(data, f, indent=4)
        self.mw.log_message(f"Parameters saved to {os.path.basename(path)}")

    def load_parameters(self):
        start_dir = self.mw._get_last_dir()
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Load Parameters", start_dir, "JSON files (*.json)"
        )
        if not path: return
        self.mw._set_last_dir(path)
        with open(path, "r") as f: data = json.load(f)
        for name, value in data.items():
            if name in self.params: self.params[name][0].setText(str(value))
        if 'mode' in data:
            index = self.mode_combo.findData(data['mode'])
            if index >= 0: self.mode_combo.setCurrentIndex(index)
        self.mw.log_message(f"Parameters loaded from {os.path.basename(path)}")

    # --- Visualization & Interaction ---

    def on_roi_selected(self, original_index):
        """Handle selection from a viewer (e.g. click on map)."""
        self.mw.log_message(f"ROI {original_index + 1} selected.")
        
        local_index = -1
        if self.filtered_indices is not None:
            matches = np.where(self.filtered_indices == original_index)[0]
            if len(matches) > 0: 
                local_index = matches[0]
        else:
            local_index = original_index

        if local_index != -1:
            traj_viewer = self.mw.visualization_widgets.get(self.mw.traj_tab)
            if traj_viewer:
                traj_viewer.set_trajectory(local_index)
                self.mw.vis_tabs.setCurrentWidget(self.mw.traj_tab)
            
            heatmap_viewer = self.mw.visualization_widgets.get(self.mw.heatmap_tab)
            if heatmap_viewer: 
                heatmap_viewer.update_selected_trace(original_index)

            com_viewer = self.mw.visualization_widgets.get(self.mw.com_tab)
            if com_viewer: 
                com_viewer.highlight_point(original_index)
                
            phase_viewer = self.mw.visualization_widgets.get(self.mw.phase_tab)
            if phase_viewer: 
                phase_viewer.highlight_point(original_index)

    def on_contrast_change(self, vmin, vmax):
        self.vmin = vmin
        self.vmax = vmax
        traj_viewer = self.mw.visualization_widgets.get(self.mw.traj_tab)
        if traj_viewer: traj_viewer.update_contrast(vmin, vmax)
        phase_viewer = self.mw.visualization_widgets.get(self.mw.phase_tab)
        if phase_viewer: phase_viewer.update_contrast(vmin, vmax)

    def _normalize_rois_for_viewers(self, rois):
        """
        Normalize ROI dicts for viewers.

        Important:
        - Some ROI dicts may already contain a matplotlib Path under key "path".
          We preserve it if present.
        - Some viewers only need path_vertices (and will rebuild Path internally).
        - Never assume "path" exists, never require it.
        """
        if not rois:
            return []

        clean = []
        for r in rois:
            verts = r.get("path_vertices", None)
            if verts is None:
                continue

            item = {
                "path_vertices": verts,
                "mode": r.get("mode", "Include"),
            }

            # Preserve prebuilt Path if present (optional, do not require).
            p = r.get("path", None)
            if isinstance(p, Path):
                item["path"] = p

            clean.append(item)

        return clean

    def populate_visualizations(self):
        if not self.state.loaded_data or "background" not in self.state.unfiltered_data: return
        
        bg = self.state.unfiltered_data["background"]
        movie = self.state.unfiltered_data.get("movie")
        if movie is None: return
        
        self.vmin, self.vmax = float(bg.min()), float(bg.max())
        
        # Enable Tabs
        for tab in [self.mw.heatmap_tab, self.mw.com_tab, self.mw.traj_tab, self.mw.phase_tab, self.mw.interp_tab]:
            self.mw.vis_tabs.setTabEnabled(self.mw.vis_tabs.indexOf(tab), True)

        # 1. Heatmap
        try:
            phases, period, sort_scores, filter_scores, rhythm_sort_desc = self._calculate_rhythms()
        except:
            phases, period, sort_scores, filter_scores, rhythm_sort_desc = None, None, None, None, True
            
        fig_h, _ = add_mpl_to_tab(self.mw.heatmap_tab)
        viewer_h = HeatmapViewer(fig_h, self.state.loaded_data, self.filtered_indices, phases, sort_scores, 
                                 self.emphasize_rhythm_check.isChecked(), rhythm_sort_desc, 
                                 period=period)
        self.mw.visualization_widgets[self.mw.heatmap_tab] = viewer_h

        # 2. CoM
        fig_c, _ = add_mpl_to_tab(self.mw.com_tab)
        
        current_rois = self._normalize_rois_for_viewers((self.rois or []) + (self.phase_reference_rois or []))
        
        viewer_c = ContrastViewer(fig_c, fig_c.add_subplot(111), bg, self.state.loaded_data["roi"], 
                                  self.on_contrast_change, self.on_roi_selected, 
                                  filtered_indices=self.filtered_indices, rois=current_rois)
        self.mw.visualization_widgets[self.mw.com_tab] = viewer_c

        # 3. Trajectory
        fig_t, _ = add_mpl_to_tab(self.mw.traj_tab)
        viewer_t = TrajectoryInspector(fig_t, fig_t.add_subplot(111), self.state.loaded_data["trajectories"], movie)
        self.mw.visualization_widgets[self.mw.traj_tab] = viewer_t

        self.regenerate_phase_maps()

    def _calculate_rhythms(self):
        method = self.analysis_method_combo.currentText()
        phase_args = {name: t(w.text()) for name, (w, t) in self.phase_params.items() 
                      if w.text() and name not in ("grid_resolution", "rhythm_threshold", "r_squared_threshold")}
        
        if not phase_args.get("minutes_per_frame"): raise ValueError("Minutes per frame is required.")
        if "trend_window_hours" in phase_args: phase_args["detrend_window_hours"] = phase_args.pop("trend_window_hours")
        
        # NOTE (tech debt): FFT is currently called twice (once for discovered_period, once for phases/scores).
        # This is acceptable for now but should be refactored later to avoid redundant work.
        
        # 1. Discover Period
        _, discovered_period, _ = calculate_phases_fft(self.state.loaded_data["traces"], **phase_args)
        self.discovered_period_edit.setText(f"{discovered_period:.2f}")
        
        # 2. Compute Metrics
        if "FFT" in method:
            phases, period, snr_scores = calculate_phases_fft(self.state.loaded_data["traces"], **phase_args)
            return phases, period, snr_scores, snr_scores, True # FFT sort descending (SNR)
        elif "Cosinor" in method:
            traces = self.state.loaded_data["traces"]
            time_points_hours = traces[:, 0] * (phase_args["minutes_per_frame"] / 60.0)
            
            phases, p_values, r_squareds = [], [], []
            
            # Use same detrend logic as FFT
            trend_window_hours = phase_args.get("detrend_window_hours", RHYTHM_TREND_WINDOW_HOURS)
            med_win = compute_median_window_frames(phase_args["minutes_per_frame"], trend_window_hours, T=traces.shape[0])
            
            for i in range(1, traces.shape[1]):
                res = csn.cosinor_analysis(
                    preprocess_for_rhythmicity(traces[:, i], method="running_median", median_window_frames=med_win),
                    time_points_hours, 
                    period=discovered_period
                )
                phases.append(res["acrophase"])
                p_values.append(res["p_value"])
                r_squareds.append(res["r_squared"])
                
            return np.array(phases), discovered_period, np.array(r_squareds), np.array(p_values), True

        return None, None, None, None, True

    @QtCore.pyqtSlot(int)
    def _on_analysis_method_changed(self, index):
        method = self.analysis_method_combo.currentText()
        thresh_edit = self.phase_params["rhythm_threshold"][0]
        
        if "FFT" in method:
            self.rhythm_threshold_label.setText("SNR Threshold (>=):")
            thresh_edit.setText("2.0")
            for w in self.rsquared_widgets: w.setVisible(False)
        elif "Cosinor" in method:
            self.rhythm_threshold_label.setText("p-value (<=):")
            thresh_edit.setText("0.05")
            # Only show R2 if in Advanced Mode, or force visibility?
            # Basic Mode rules say R2 is visible for Cosinor.
            # So we respect the current mode logic or just show it if Basic?
            # User requirement: "Show r_squared_threshold widgets" if Cosinor selected.
            # But check Advanced/Basic toggle.
            is_adv = self.chk_advanced_mode.isChecked()
            # If basic, we still show R2 if Cosinor is picked.
            for w in self.rsquared_widgets: w.setVisible(True)

    def regenerate_phase_maps(self):
        if not self.state.loaded_data or "traces" not in self.state.loaded_data: return
        
        self.btn_save_rhythm.setEnabled(False)
        for tab in (self.mw.phase_tab, self.mw.interp_tab): clear_layout(tab.layout())
        
        try:
            phases, period, sort_scores, filter_scores, sort_desc = self._calculate_rhythms()
            if phases is None: return
            
            method = self.analysis_method_combo.currentText()
            thresh = float(self.phase_params["rhythm_threshold"][0].text())
            mpf = float(self.phase_params["minutes_per_frame"][0].text())
            try: trend_win = float(self.phase_params["trend_window_hours"][0].text())
            except: trend_win = 36.0
            
            # --- Rhythm Gating ---
            if "Cosinor" in method:
                r_thresh = float(self.phase_params["r_squared_threshold"][0].text())
                rhythm_mask = (filter_scores <= thresh) & (sort_scores >= r_thresh)
                phases_hours = phases
            else:
                rhythm_mask = filter_scores >= thresh
                phases_hours = ((phases / (2 * np.pi)) * period) % period
                
            if self.strict_cycle_check.isChecked():
                rhythm_mask = strict_cycle_mask(self.state.loaded_data["traces"], mpf, period, rhythm_mask, min_cycles=2, trend_window_hours=trend_win)
            
            # --- Emphasis & Viewers ---
            com_viewer = self.mw.visualization_widgets.get(self.mw.com_tab)
            if com_viewer: com_viewer.update_rhythm_emphasis(rhythm_mask, self.emphasize_rhythm_check.isChecked())
            
            heatmap_viewer = self.mw.visualization_widgets.get(self.mw.heatmap_tab)
            if heatmap_viewer: 
                heatmap_viewer.update_phase_data(phases_hours, sort_scores, rhythm_mask, sort_desc, period=period, minutes_per_frame=mpf)

            rhythmic_indices = np.where(rhythm_mask)[0]
            if len(rhythmic_indices) == 0:
                self.mw.log_message("No rhythmic cells found.")
                return

            # --- Reference Phase ---
            mean_h = 0.0
            
            if self.use_subregion_ref_check.isChecked() and self.phase_reference_rois:
                # Calc subset mean
                r_coords = self.state.loaded_data['roi'][rhythmic_indices]
                sub_mask = np.zeros(len(r_coords), dtype=bool)
                for r in self.phase_reference_rois:
                    p = Path(r["path_vertices"])
                    sub_mask |= p.contains_points(r_coords)
                
                if sub_mask.sum() > 0:
                    sub_phases = phases_hours[rhythmic_indices][sub_mask]
                    rads = (sub_phases % period) * (2 * np.pi / period)
                    mean_h = (circmean(rads) / (2 * np.pi)) * period
                    self.mw.log_message(f"Ref Phase (Subregion): {mean_h:.2f}h")
                else:
                    self.mw.log_message("Ref Region empty of rhythmic cells. Using global mean.")
                    rads = (phases_hours[rhythmic_indices] % period) * (2 * np.pi / period)
                    mean_h = (circmean(rads) / (2 * np.pi)) * period
            else:
                rads = (phases_hours[rhythmic_indices] % period) * (2 * np.pi / period)
                mean_h = (circmean(rads) / (2 * np.pi)) * period

            # --- Dataframes ---
            rel_phases = (phases_hours[rhythmic_indices] - mean_h + period / 2) % period - period / 2
            
            orig_indices = self.filtered_indices[rhythmic_indices] if self.filtered_indices is not None else rhythmic_indices
            
            df_map = pd.DataFrame({
                'Original_ROI_Index': orig_indices + 1,
                'X_Position': self.state.loaded_data['roi'][rhythmic_indices, 0],
                'Y_Position': self.state.loaded_data['roi'][rhythmic_indices, 1],
                'Relative_Phase_Hours': rel_phases,
                'Period_Hours': period
            })
            
            # Save DF (Full set for group)
            if "Cosinor" in method:
                 raw_phases = phases
            else:
                 raw_phases = ((phases / (2 * np.pi)) * period) % period
                 
            self.latest_rhythm_df = pd.DataFrame({
                'Original_ROI_Index': np.arange(len(phases)) + 1,
                'Phase_Hours': raw_phases,
                'Period_Hours': period,
                'Is_Rhythmic': rhythm_mask,
                'Metric_Score': sort_scores, # R2 or SNR
                'Filter_Score': filter_scores # p-value or SNR
            })
            self.btn_save_rhythm.setEnabled(True)

            # --- Map Viewers ---
            def on_map_click(idx):
                if 0 <= idx < len(df_map):
                    self.on_roi_selected(int(df_map.iloc[idx]['Original_ROI_Index']) - 1)

            fig_p, _ = add_mpl_to_tab(self.mw.phase_tab)
            viewer_p = PhaseMapViewer(fig_p, fig_p.add_subplot(111), self.state.unfiltered_data["background"], df_map, on_map_click, vmin=self.vmin, vmax=self.vmax)
            self.mw.visualization_widgets[self.mw.phase_tab] = viewer_p
            
            grid_res = int(self.phase_params["grid_resolution"][0].text())
            fig_i, _ = add_mpl_to_tab(self.mw.interp_tab)
            
            # Fix: Ensure ROIs are clean dicts for interpolator
            clean_rois = self._normalize_rois_for_viewers(self.rois)
            viewer_i = InterpolatedMapViewer(fig_i, fig_i.add_subplot(111), df_map[['X_Position', 'Y_Position']].values, df_map['Relative_Phase_Hours'].values, period, grid_res, rois=clean_rois)
            self.mw.visualization_widgets[self.mw.interp_tab] = viewer_i
            
        except Exception as e:
            self.mw.log_message(f"Plot Error: {e}")

    def save_rhythm_results(self):
        """
        Save the most recent rhythm results table to CSV.

        Uses:
        - self.latest_rhythm_df (set in regenerate_phase_maps)
        - self.state.output_basename (for default filename)
        """
        if self.latest_rhythm_df is None or len(self.latest_rhythm_df) == 0:
            self.mw.log_message("No rhythm results available to save. Click 'Update Plots' first.")
            return

        start_dir = self.mw._get_last_dir()
        default_name = "rhythm_results.csv"
        if getattr(self.state, "output_basename", None):
            default_name = os.path.basename(self.state.output_basename) + "_rhythm_results.csv"

        path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save Rhythm Results",
            os.path.join(start_dir, default_name),
            "CSV files (*.csv)"
        )
        if not path:
            return

        self.mw._set_last_dir(path)
        try:
            self.latest_rhythm_df.to_csv(path, index=False)
            self.mw.log_message(f"Rhythm results saved: {os.path.basename(path)}")
        except Exception as e:
            self.mw.log_message(f"Failed to save rhythm results: {e}")

    def export_current_plot(self):
        widget = self.mw.vis_tabs.currentWidget()
        viewer = self.mw.visualization_widgets.get(widget)
        if not viewer or not hasattr(viewer, "fig"): return
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Plot", self.mw._get_last_dir(), "PNG (*.png)")
        if path: viewer.fig.savefig(path, dpi=300, bbox_inches="tight")

    def export_current_data(self):
        widget = self.mw.vis_tabs.currentWidget()
        viewer = self.mw.visualization_widgets.get(widget)
        if viewer and hasattr(viewer, "get_export_data"):
            df, name = viewer.get_export_data()
            if df is not None:
                path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Export", os.path.join(self.mw._get_last_dir(), name), "CSV (*.csv)")
                if path: df.to_csv(path, index=False)

